#version 460

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require

#include "common_defines.h"
#include "common_structures.h"

layout (set = COMPUTE_SHADE_LAYOUT_INDEX, binding = COMPUTE_SHADE_OUTPUT_IMAGE_INDEX, rgba32f) uniform image2D OutcomingImage;

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_MATERIAL_BUFFER_INDEX) buffer MaterialsBufferObject
{
    FMaterial Materials[];
};

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_RENDERABLE_BUFFER_INDEX) buffer FRenderablesBuffer
{
    FRenderable Renderables[];
};

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_TRANSFORM_INDEX) buffer TransformsBufferObject
{
    FMatrix4 Transforms[];
};

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_HITS_BUFFER_INDEX) buffer HitsBufferObject
{
    FHit Hits[];
};

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_RAYS_BUFFER_INDEX) buffer RaysBufferObject
{
    FRayData RayData[];
};

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_TEXTURE_SAMPLER) uniform sampler Sampler;

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_TEXTURE_ARRAY) uniform texture2D Textures[MAX_TEXTURES];

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_IBL_IMAGE_INDEX) uniform sampler2D IBITextureSampler;

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_LIGHTS_BUFFER_INDEX) buffer LightsBufferObject
{
    FLight Lights[];
};

layout (set = RAYTRACE_LAYOUT_INDEX, binding = RAYTRACE_SHADE_MATERIAL_INDEX_MAP) buffer MaterialIndexBufferObject
{
    uint MaterialsIndexMap[];
};

layout (buffer_reference, scalar) buffer Vertices
{
    FVertex V[];
};

layout (buffer_reference, scalar) buffer Indices
{
    ivec3 I[];
};

FRenderable FetchRenderable(uint RenderableIndex)
{
    return Renderables[RenderableIndex];
}

FMaterial FetchMaterial(uint MaterialIndex)
{
    return Materials[MaterialIndex];
}

FHit FetchHit(uint HitIndex)
{
    return Hits[HitIndex];
}

mat4 FetchTransform(uint TransformIndex)
{
    return Transforms[nonuniformEXT(TransformIndex)];
}

FRayData FetchRayData(uint RayIndex)
{
    return RayData[RayIndex];
}

FLight FetchLightData(uint LightIndex)
{
    return Lights[LightIndex];
}

bool CheckFlag(uint Mask, uint Field)
{
    if ((Mask & Field) == Field)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool IsIndexed(FRenderable Renderable)
{
    return CheckFlag(Renderable.RenderablePropertyMask, RENDERABLE_IS_INDEXED);
}

layout (push_constant) uniform PushConstantsBlock
{
    FPushConstants PushConstants;
};

layout (local_size_x = BASIC_CHUNK_SIZE, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint OriginalPixelIndex = gl_GlobalInvocationID.x;

    if (OriginalPixelIndex >= PushConstants.TotalSize)
    {
        return;
    }

    uint NewPixelIndex = MaterialsIndexMap[OriginalPixelIndex];
    uvec2 NewPixelCoords = uvec2(NewPixelIndex % PushConstants.Width, NewPixelIndex / PushConstants.Width);

    FHit Hit = FetchHit(NewPixelIndex);
    FRenderable Renderable = FetchRenderable(Hit.RenderableIndex);
    FMaterial Material = FetchMaterial(Renderable.MaterialIndex);

    if (Hit.RenderableIndex == UINT_MAX)
    {
        vec3 NormalizedDirection = FetchRayData(NewPixelIndex).Direction.xyz;
        float Tmp = atan(NormalizedDirection.z, NormalizedDirection.x);
        float Phi = Tmp < 0.f ? (Tmp + (2 * 3.14159265357)) : Tmp;
        float Theta = acos(NormalizedDirection.y);
        Phi /= 2.f * 3.14159265357;
        Theta /= 3.14159265357;

        imageStore(OutcomingImage, ivec2(NewPixelCoords), vec4(vec3(texture(IBITextureSampler, vec2(Phi, Theta))), 1.f));

        return;
    }

    Vertices Verts = Vertices(Renderable.VertexBufferAddress);
    Indices Inds = Indices(Renderable.IndexBufferAddress);
    mat4 Transform = FetchTransform(Renderable.TransformIndex);

    vec3 Normal = vec3(1.f, 1.f, 1.f);

    FVertex V0;
    FVertex V1;
    FVertex V2;

    if (IsIndexed(Renderable))
    {
        uint I0 = 0;
        uint I1 = 1;
        uint I2 = 2;

        uvec3 I =  Inds.I[Hit.PrimitiveIndex];
        I0 = I.x;
        I1 = I.y;
        I2 = I.z;

        V0 = Verts.V[I0];
        V1 = Verts.V[I1];
        V2 = Verts.V[I2];
        vec3 V10 = V1.Position - V0.Position;
        vec3 V20 = V2.Position - V0.Position;
        vec3 Cross = normalize(cross(V10, V20));

        Normal = vec3(Cross);
    }
    else
    {
        uint Index = Hit.PrimitiveIndex * 3;
        V0 = Verts.V[Index];
        V1 = Verts.V[Index + 1];
        V2 = Verts.V[Index + 2];

        Normal = normalize(cross((V1.Position - V0.Position), (V2.Position - V0.Position)));
    }

    const vec3 Barycentrics = vec3(1.0 - Hit.HitUV.x - Hit.HitUV.y, Hit.HitUV.x, Hit.HitUV.y);
    vec2 TextureCoords = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;

    vec3 PointOfIntersectionInLocalSpace = V0.Position * Barycentrics.x + V1.Position * Barycentrics.y + V2.Position * Barycentrics.z;
    vec3 PointOfIntersectionInWorldSpace = vec3(Transform * vec4(PointOfIntersectionInLocalSpace, 1.f));
    
    FLight Light = FetchLightData(0);
    vec3 PointOfIntersectioToLightDirection = Light.Position - PointOfIntersectionInWorldSpace;
    float CosNormalToLightAngle = dot(normalize(PointOfIntersectioToLightDirection), Normal);
    float Distance2 = dot(PointOfIntersectioToLightDirection, PointOfIntersectioToLightDirection);
    float Luminance = Light.Intensity * CosNormalToLightAngle / Distance2;

    vec3 ColorOut = texture(sampler2D(Textures[Renderable.MaterialIndex], Sampler), TextureCoords).rgb;

    imageStore(OutcomingImage, ivec2(NewPixelCoords), vec4(ColorOut, 1.f));
}