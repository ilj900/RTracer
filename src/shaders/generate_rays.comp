#version 460

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#define DEBUG_PRINTF
#ifdef DEBUG_PRINTF
#extension GL_EXT_debug_printf : enable
bool b = false;
#endif

#include "common_defines.h"
#include "common_structures.h"
#include "cmj.h"

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = CAMERA_RAYS_BUFFER) buffer RaysBufferObject
{
    FRayData RayData[];
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = CAMERA_POSITION_BUFFER) uniform CameraBufferObject
{
    FDeviceCamera DeviceCamera;
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = GENERATE_RAYS_PIXEL_INDEX_BUFFER) buffer PixelIndexIndexMapBufferObject
{
    uint PixelIndexIndexMap[];
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = GENERATE_RAYS_RENDER_ITERATION_BUFFER) buffer RenderIterationBufferObject
{
    uint RenderIteration;
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = GENERATE_RAYS_THROUGHPUT_BUFFER) buffer ThroughputBufferObject
{
    vec4 ThroughputBuffer[];
};

layout (push_constant) uniform PushConstantsBlock
{
    FPushConstants PushConstants;
};

layout (local_size_x = BASIC_CHUNK_SIZE, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint PixelIndex = gl_GlobalInvocationID.x;

    if (PixelIndex >= PushConstants.TotalSize)
    {
        return;
    }

    uvec2 PixelCoords = uvec2(PixelIndex % PushConstants.Width, PixelIndex / PushConstants.Width);

    #ifdef DEBUG_PRINTF
    if (PixelCoords.x == PushConstants.Width / 2 && PixelCoords.y == PushConstants.Height / 2 && PushConstants.BounceIndex == 0)
    {
        b = true;
    }
    #endif

    vec2 PixelCoordsF = PixelCoords / vec2(PushConstants.Width, PushConstants.Height);
    /// -= vec2(0.5) so that the center would be (0, 0)
    PixelCoordsF -= vec2(0.5);

    FSamplingState SamplingState = FSamplingState(PixelIndex, 0, RenderIteration);
    const vec2 PixelJitter = (Sample2D(SamplingState) - vec2(0.5)) / vec2(PushConstants.Width, PushConstants.Height);

    PixelCoordsF += PixelJitter;

    if (b)
    {
        debugPrintfEXT("DeviceCamera.Origin is %f, %f, %f\n", DeviceCamera.Origin.x, DeviceCamera.Origin.y, DeviceCamera.Origin.z);
        debugPrintfEXT("DeviceCamera.Direction is %f, %f, %f\n", DeviceCamera.Direction.x, DeviceCamera.Direction.y, DeviceCamera.Direction.z);
        debugPrintfEXT("DeviceCamera.Up is %f, %f, %f\n", DeviceCamera.Up.x, DeviceCamera.Up.y, DeviceCamera.Up.z);
        debugPrintfEXT("DeviceCamera.Right is %f, %f, %f\n", DeviceCamera.Right.x, DeviceCamera.Right.y, DeviceCamera.Right.z);
        debugPrintfEXT("DeviceCamera.SensorSize is %f, %f\n", DeviceCamera.SensorSizeX, DeviceCamera.SensorSizeY);
        debugPrintfEXT("DeviceCamera.FocalDistance is %f\n", DeviceCamera.FocalDistance);
    }

    vec4 RayOrigin = vec4(DeviceCamera.Origin, 1.f);
    const float AspectRation = (DeviceCamera.SensorSizeX / DeviceCamera.SensorSizeY) / (PushConstants.Width / PushConstants.Height);
    const float AdjustedSensorSizeY = DeviceCamera.SensorSizeY *0.84375;
    vec3 SensorCenter = DeviceCamera.Origin - DeviceCamera.Direction * DeviceCamera.FocalDistance;
    vec3 PixelOrigin = SensorCenter + DeviceCamera.Right * DeviceCamera.SensorSizeX * PixelCoordsF.x + DeviceCamera.Up * AdjustedSensorSizeY * PixelCoordsF.y;

    vec4 RayDirection = vec4(normalize(DeviceCamera.Origin - PixelOrigin), 1);

    float tMin = 0.001f;
    float tMax = 10000.f;

    RayData[PixelIndex] = FRayData(RayOrigin, RayDirection, 0, tMin, tMax, 1.f);
    ThroughputBuffer[PixelIndex] = vec4(1);
    PixelIndexIndexMap[PixelIndex] = PixelIndex;
}