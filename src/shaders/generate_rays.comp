#version 460

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "common_defines.h"
#include "common_structures.h"

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = CAMERA_RAYS_BUFFER) buffer RaysBufferObject
{
    FRayData RayData[];
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = CAMERA_POSITION_BUFFER) uniform CameraBufferObject
{
    FDeviceCamera DeviceCamera;
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = GENERATE_RAYS_PIXEL_INDEX_BUFFER) buffer PixelIndexIndexMapBufferObject
{
    uint PixelIndexIndexMap[];
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = GENERATE_RAYS_RANDOM_SEEDS_BUFFER) buffer RandomSeedBufferObject
{
    uint RandomSeed[];
};

layout (set = GENERATE_RAYS_LAYOUT_INDEX, binding = GENERATE_RAYS_DEBUG_BUFFER) buffer DebugBufferObject
{
    vec4 DebugBuffer[];
};

layout (push_constant) uniform PushConstantsBlock
{
    FPushConstants PushConstants;
};

uint Permute(uint I, uint L, uint P)
{
    uint W = L - 1;
    W |= W >> 1;
    W |= W >> 2;
    W |= W >> 4;
    W |= W >> 8;
    W |= W >> 16;

    do
    {
        I ^= P;
        I *= 0xe170893d;
        I ^= P >> 16;
        I ^= (I & W) >> 4;
        I ^= P >> 8;
        I *= 0x0929eb3f;
        I ^= P >> 23;
        I ^= (I & W) >> 1;
        I *= 1 | P >> 27;
        I *= 0x6935fa69;
        I ^= (I & W) >> 11;
        I *= 0x74dcb303;
        I ^= (I & W) >> 2;
        I *= 0x9e501cc3;
        I ^= (I & W) >> 2;
        I *= 0xc860a3df;
        I &= W;
        I ^= I >> 5;
    } while (I >= L);

    return (I + P) % L;
}

float RandomFloat(uint I, uint P)
{
    I ^= P;
    I ^= I >> 17;
    I ^= I >> 10;
    I *= 0xb36534e5;
    I ^= I >> 12;
    I ^= I >> 21;
    I *= 0x93fc4795;
    I ^= 0xdf6e307f;
    I ^= I >> 17;
    I *= 1 | P >> 18;
    return I * (1.f / 4294967808.f);
}

vec2 CMJ(uint S, uint M, uint N, uint P)
{
    uint SX = Permute(S % M, M, P * 0xa511e9b3);
    uint SY = Permute(S / M, N, P * 0x63d83595);
    float JX = RandomFloat(S, P * 0xa399d265);
    float JY = RandomFloat(S, P * 0x711ad6a5);

    vec2 Result = {(S % M + (SY + JX) / N) / M, (S / M + (SX + JY) /M) / N};

    return Result;
}

layout (local_size_x = BASIC_CHUNK_SIZE, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint PixelIndex = gl_GlobalInvocationID.x;
    uvec2 PixelCoords = uvec2(gl_GlobalInvocationID.x % PushConstants.Width, gl_GlobalInvocationID.x / PushConstants.Width);

    if (PixelIndex >= PushConstants.TotalSize)
    {
        return;
    }

    const vec2 PixelCenter = PixelCoords + CMJ(gl_GlobalInvocationID.x, 64, 64, 1);

    DebugBuffer[PixelIndex] = vec4(CMJ(gl_GlobalInvocationID.x % 16, 4, 4, gl_GlobalInvocationID.x / 16), 0.f, 1.f);

    const vec2 InUV = PixelCenter * vec2(PushConstants.InvWidth, PushConstants.InvHeight);
    vec2 D = InUV * 2.0f - 1.f;

    vec4 Origin = vec4(DeviceCamera.Origin, 1.f);
    vec4 Target = DeviceCamera.InverseProjectionMatrix * vec4(D.x, D.y, 1.f, 1.f);
    vec4 Direction = DeviceCamera.InverseViewMatrix * vec4(normalize(Target.xyz), 0.f);

    float tMin = 0.001f;
    float tMax = 10000.f;

    RayData[gl_GlobalInvocationID.x] = FRayData(Origin, Direction, 0, tMin, tMax, 0.f);
    PixelIndexIndexMap[gl_GlobalInvocationID.x] = gl_GlobalInvocationID.x;
}