#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : enable // ?

#define DEBUG_PRINTF
#ifdef DEBUG_PRINTF
#extension GL_EXT_debug_printf : enable
bool b = false;
#endif

vec4 DebugGlobal0 = vec4(0);
vec4 DebugGlobal1 = vec4(0);
vec4 DebugGlobal2 = vec4(0);
vec4 DebugGlobal3 = vec4(0);

struct FShadingData
{
    /// Direction from the camera to the intersection point
    vec3 WorldSpaceIncomingDirection;
    /// Direction from the surface
    vec3 WorldSpaceOutgoingDirection;
    vec3 TangentSpaceIncomingDirection;
    vec3 TangentSpaceOutgoingDirection;
    vec3 NormalInWorldSpace;
    vec3 NormalInTangentSpace;
    vec3 IntersectionCoordinatesInWorldSpace;
    vec2 UVCoordinates;
    mat3 TNBMatrix;
    mat3 TransposedTNBMatrix;
};

#include "common_defines.h"
#include "common_structures.h"
#include "random.h"

FShadingData ShadingData;
FDeviceMaterial Material;
uint RayType;

#include "glsl_math.h"
#include "bxdf.h"
#include "process_material_interaction.h"

layout (location = 0) rayPayloadEXT FHitPayload HitPayload;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TLAS_INDEX) uniform accelerationStructureEXT TLAS;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TEXTURE_SAMPLER) uniform sampler Sampler;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TEXTURE_ARRAY) uniform texture2D Textures[MAX_TEXTURES];

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RAYS_BUFFER_INDEX) buffer RaysBufferObject
{
    FRayData RayDataBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_HITS_BUFFER_INDEX) buffer HitsBufferObject
{
    FHit Hits[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDERABLES_BUFFER_INDEX) buffer RenderablesBufferObject
{
    FRenderable Renderables[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TRANSFORMS_BUFFER_INDEX) buffer TransformsBufferObject
{
    FDeviceTransform DeviceTransforms[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_MATERIALS_OFFSETS) buffer MaterialsOffsetsBufferObject
{
    uint MaterialsOffsets[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_PIXEL_INDEX_BUFFER) buffer PixelIndexIndexMapBufferObject
{
    uint PixelIndexIndexMap[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DIRECTIONAL_LIGHTS_BUFFER_INDEX) buffer DirectionalLightsBufferObject
{
    FDirectionalLight DirectionalLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DIRECTIONAL_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer DirectionalLightsImportanceBufferObject
{
    FDeviceAliasTableEntry DirectionalLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SPOT_LIGHTS_BUFFER_INDEX) buffer SpotLightsBufferObject
{
    FSpotLight SpotLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SPOT_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer SpotLightsImportanceBufferObject
{
    FDeviceAliasTableEntry SpotLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_POINT_LIGHTS_BUFFER_INDEX) buffer PointLightsBufferObject
{
    FPointLight PointLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_POINT_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer PointLightsImportanceBufferObject
{
    FDeviceAliasTableEntry PointLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_IMPORTANCE_BUFFER_INDEX) buffer IBLImportanceBufferObject
{
    FDeviceAliasTableEntry IBLImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_IMAGE_SAMPLER_INDEX) uniform sampler2D IBLTextureSampler;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_WEIGHTS_BUFFER_INDEX) buffer IBLPDFBufferObject
{
    float IBLPDFBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_UTILITY_BUFFER_INDEX) uniform UtilityDataUniformBufferObject
{
    FUtilityData UtilityData;
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDER_ITERATION_BUFFER_INDEX) buffer RenderIterationBufferObject
{
    uint RenderIteration;
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_CUMULATIVE_MATERIAL_COLOR_BUFFER_INDEX) buffer CumulativeMaterialColorBufferObject
{
    vec4 CumulativeMaterialColorBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_NORMAL_BUFFER) buffer NormalBufferObject
{
    vec4 NormalBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_THROUGHPUT_BUFFER) buffer ThroughputBufferObject
{
    vec4 ThroughputBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_COLOR_AOV_IMAGE_INDEX, rgba32f) uniform image2D OutcomingImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SHADING_NORMAL_AOV_IMAGE_INDEX, rgba32f) uniform image2D ShadingNormalAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_GEOMETRIC_NORMAL_AOV_IMAGE_INDEX, rgba32f) uniform image2D GeometricNormalAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_UV_AOV_IMAGE_INDEX, rg32f) uniform image2D UVAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_WORLD_SPACE_POSITION_AOV_IMAGE_INDEX, rgba32f) uniform image2D WorldSpacePositionAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_OPACITY_AOV_IMAGE_INDEX, rgba32f) uniform image2D OpacityAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEPTH_AOV_IMAGE_INDEX, rgba32f) uniform image2D DepthAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_ALBEDO_AOV_IMAGE_INDEX, rgba32f) uniform image2D AlbedoAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_LUMINANCE_AOV_IMAGE_INDEX, rgba32f) uniform image2D LuminanceAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDERABLE_INDEX_IMAGE_INDEX, rgba32f) uniform image2D RenderableIndexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_PRIMITIVE_INDEX_IMAGE_INDEX, rgba32f) uniform image2D PrimitiveIndexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_MATERIAL_INDEX_IMAGE_INDEX, rgba32f) uniform image2D MaterialindexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_0_INDEX, rgba32f) uniform image2D DebugLayerImage0;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_1_INDEX, rgba32f) uniform image2D DebugLayerImage1;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_2_INDEX, rgba32f) uniform image2D DebugLayerImage2;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_3_INDEX, rgba32f) uniform image2D DebugLayerImage3;

layout (buffer_reference, scalar) buffer Vertices
{
    FDeviceVertex V[];
};

layout (buffer_reference, scalar) buffer Indices
{
    int I[];
};

layout (push_constant) uniform PushConstantsBlock
{
    FPushConstants PushConstants;
};

bool CheckFlag(uint Mask, uint Field)
{
    return (Mask & Field) == Field;
}

bool IsIndexed(FRenderable Renderable)
{
    return CheckFlag(Renderable.RenderablePropertyMask, RENDERABLE_IS_INDEXED);
}

FVertex UnpackDeviceVertex(FDeviceVertex DV)
{
    FVertex V;
    V.Position.x = DV.A.x;
    V.Position.y = DV.A.y;
    V.Position.z = DV.A.z;
    V.Normal.x = DV.A.w;
    V.Normal.y = DV.B.x;
    V.Normal.z = DV.B.y;
    V.TexCoord.x = DV.B.z;
    V.TexCoord.y = DV.B.w;
    return V;
}

vec3 SampleVec3(uint TextureIndex, vec2 TextureCoords)
{
    return texture(sampler2D(Textures[TextureIndex], Sampler), TextureCoords).rgb;
}

float SampleFloat(uint TextureIndex, vec2 TextureCoords)
{
    return texture(sampler2D(Textures[TextureIndex], Sampler), TextureCoords).r;
}

FDeviceMaterial GetMaterial(vec2 TextureCoords);

void ComputeShadingData(FRenderable Renderable, FHit Hit, FDeviceTransform Transform, FRayData RayData)
{
    Vertices Verts = Vertices(Renderable.VertexBufferAddress);
    Indices Inds = Indices(Renderable.IndexBufferAddress);
    vec3 Barycentrics = vec3(1.0 - Hit.HitUV.x - Hit.HitUV.y, Hit.HitUV.x, Hit.HitUV.y);

    FDeviceVertex DV0;
    FDeviceVertex DV1;
    FDeviceVertex DV2;

    if (IsIndexed(Renderable))
    {
        uint I0 = 0;
        uint I1 = 1;
        uint I2 = 2;

        I0 = Inds.I[Hit.PrimitiveIndex * 3];
        I1 = Inds.I[Hit.PrimitiveIndex * 3 + 1];
        I2 = Inds.I[Hit.PrimitiveIndex * 3 + 2];

        DV0 = Verts.V[I0];
        DV1 = Verts.V[I1];
        DV2 = Verts.V[I2];
    }
    else
    {
        uint Index = Hit.PrimitiveIndex * 3;
        DV0 = Verts.V[Index];
        DV1 = Verts.V[Index + 1];
        DV2 = Verts.V[Index + 2];
    }

    FVertex V0 = UnpackDeviceVertex(DV0);
    FVertex V1 = UnpackDeviceVertex(DV1);
    FVertex V2 = UnpackDeviceVertex(DV2);

    ShadingData.NormalInWorldSpace = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
    /// Pay more attention to why vector * matrix, and not vice versa
    ShadingData.NormalInWorldSpace = ShadingData.NormalInWorldSpace * mat3(Transform.InverseModelMatrix);
    ShadingData.NormalInWorldSpace = normalize(ShadingData.NormalInWorldSpace);

    ShadingData.TNBMatrix = CreateTNBMatrix(ShadingData.NormalInWorldSpace);
    ShadingData.TransposedTNBMatrix = transpose(ShadingData.TNBMatrix);

    ShadingData.WorldSpaceIncomingDirection = RayData.Direction.xyz;
    ShadingData.TangentSpaceIncomingDirection = ShadingData.WorldSpaceIncomingDirection * ShadingData.TNBMatrix;

    ShadingData.IntersectionCoordinatesInWorldSpace = V0.Position * Barycentrics.x + V1.Position * Barycentrics.y + V2.Position * Barycentrics.z;
    ShadingData.IntersectionCoordinatesInWorldSpace = vec3(vec4(ShadingData.IntersectionCoordinatesInWorldSpace, 1.f) * Transform.ModelMatrix);

    /// TODO: Can Hit.HitUV just be used?
    ShadingData.UVCoordinates = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;
}

vec4 ComputeUniformPointLightInput(inout FSamplingState SamplingState, uint PointLightsCount, out vec3 Direction, inout float ImportanceSamplingPDF)
{
    /// Get light index
    const uint LightIndex = uint(RandomFloat(SamplingState) * PointLightsCount);
    FPointLight PointLightUniform = PointLightsBuffer[LightIndex];
    Direction = PointLightUniform.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;
        /// Here, the probability of sampling a particular point light is one to the number of point lights
        ImportanceSamplingPDF = PointLightUniform.Power / UtilityData.TotalPointLightPower;
        return vec4(PointLightUniform.Color * PointLightUniform.Intensity * Attenuation * NDotI * PointLightsCount, 1.f / PointLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportancePointLightInput(inout FSamplingState SamplingState, uint PointLightsCount, out vec3 Direction, inout float UniformSamplingPDF)
{
    /// Get light index by importance sampling it
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * PointLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = PointLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FPointLight PointLightImportance = PointLightsBuffer[ImportanceLightIndex];

    Direction = PointLightImportance.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;
        /// Here, the probability of sampling a particular point light depends on it's power and total power of all lights
        float PDF = PointLightImportance.Power / UtilityData.TotalPointLightPower;
        UniformSamplingPDF = 1.f / PointLightsCount;
        return vec4(PointLightImportance.Color * PointLightImportance.Intensity * Attenuation * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformDirectionalLightInput(inout FSamplingState SamplingState, uint DirectionalLightsCount, out vec3 Direction, inout float ImportanceSamplingPDF)
{
    /// Get light index by uniformly sampling it
    const uint LightIndex = uint(RandomFloat(SamplingState) * DirectionalLightsCount);
    FDirectionalLight DirectionalLight = DirectionalLightsBuffer[LightIndex];

    /// Check whether light is over the surface
    Direction = -DirectionalLight.Direction;
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        /// Here, the probability of sampling a particular directional light is one to the number of directional lights
        ImportanceSamplingPDF = DirectionalLight.Power / UtilityData.TotalDirectionalLightPower;
        return vec4(DirectionalLight.Color * DirectionalLight.Intensity * NDotI * DirectionalLightsCount, 1.f / DirectionalLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

/// Sample a directional light by it's power
vec4 ComputeImportanceDirectionalLightInput(inout FSamplingState SamplingState, uint DirectionalLightsCount, out vec3 Direction, inout float UniformSamplingPDF)
{
    /// Get light index by importance sampling it
    uint LightIndex = uint(RandomFloat(SamplingState) * DirectionalLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = DirectionalLightsImportanceBuffer[LightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        LightIndex = ImportanceSampleTableEntry.Alias;
    }

    FDirectionalLight DirectionalLight = DirectionalLightsBuffer[LightIndex];

    Direction = -DirectionalLight.Direction;

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        /// Here, the probability of sampling a particular directional light is it's power to the total power of all directional light
        float PDF = DirectionalLight.Power / UtilityData.TotalDirectionalLightPower;
        UniformSamplingPDF = 1.f / DirectionalLightsCount;
        return vec4(DirectionalLight.Color * DirectionalLight.Intensity * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformSpotLightInput(inout FSamplingState SamplingState, uint SpotLightsCount, out vec3 Direction, inout float ImportanceSamplingPDF)
{
    /// Get light index
    const uint LightIndex = uint(RandomFloat(SamplingState) * SpotLightsCount);
    FSpotLight SpotLight = SpotLightsBuffer[LightIndex];
    Direction = SpotLight.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    float LightAngle = acos(dot(SpotLight.Direction, -Direction));
    /// If point is outside out outer angle, it is also not illuminated
    if (LightAngle > SpotLight.OuterAngle)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;

        /// If point between outer and inner angle - interpolate
        if (LightAngle > SpotLight.InnerAngle)
        {
            float Fraction = LightAngle - SpotLight.InnerAngle;
            float Delta = SpotLight.OuterAngle - SpotLight.InnerAngle;
            Fraction = Fraction / Delta;
            Attenuation *= pow((1. - Fraction), 2.4);
        }

        /// Here, the probability of sampling a particular spot light is one to the number of spot lights
        ImportanceSamplingPDF = SpotLight.Power / UtilityData.TotalSpotLightPower;
        return vec4(SpotLight.Color * SpotLight.Intensity * Attenuation * NDotI * SpotLightsCount, 1.f / SpotLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportanceSpotLightInput(inout FSamplingState SamplingState, uint SpotLightsCount, out vec3 Direction, inout float UniformSamplingPDF)
{
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * SpotLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = SpotLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FSpotLight SpotLightImportance = SpotLightsBuffer[ImportanceLightIndex];

    Direction = SpotLightImportance.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    float LightAngle = acos(dot(SpotLightImportance.Direction, -Direction));
    /// If point is outside out outer angle, it is also not illuminated
    if (LightAngle > SpotLightImportance.OuterAngle)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;

        /// If point between outer and inner angle - interpolate
        if (LightAngle > SpotLightImportance.InnerAngle)
        {
            float Fraction = LightAngle - SpotLightImportance.InnerAngle;
            float Delta = SpotLightImportance.OuterAngle - SpotLightImportance.InnerAngle;
            Fraction = Fraction / Delta;
            Attenuation *= pow((1. - Fraction), 2.4);
        }

        /// Here, the probability of sampling a particular spot light is dependent on the spot light's power and total spot lights power
        float PDF = SpotLightImportance.Power / UtilityData.TotalSpotLightPower;
        UniformSamplingPDF = 1.f / SpotLightsCount;
        return vec4(SpotLightImportance.Color * SpotLightImportance.Intensity * Attenuation * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformIBLInput(inout FSamplingState SamplingState, out vec3 LightDirection, inout float UniformSamplingImportancePDF, inout float UniformSamplingBXDFPDF)
{
    /// TODO: Verify that sampling is uniform
    /// Sample a random direction in the hemisphere and transform it into world-space cs
    const vec3 TangentSpaceRandomDirection = Sample3DUnitHemisphere(SamplingState);
    LightDirection = TangentSpaceRandomDirection * ShadingData.TransposedTNBMatrix;

    float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Phi = atan(RayData.Direction.z, RayData.Direction.x);
        Phi += M_PI_2;
        Phi = mod(Phi, M_2_PI);
        float Theta = asin(RayData.Direction.y);
        Phi /= M_2_PI;
        Theta /= M_PI;

        const uvec2 IBLSize = textureSize(IBLTextureSampler, 0);
        uint TexelIndex = uint(Theta * IBLSize.x * IBLSize.y) + uint(Phi * IBLSize.x);

        float PDF = 0.5f * M_INV_PI;
        UniformSamplingImportancePDF = IBLPDFBuffer[TexelIndex];
        UniformSamplingBXDFPDF = EvaluateScatteringPDF(Material, RayType, LightDirection);
        return vec4(texture(IBLTextureSampler, vec2(Phi, Theta)).xyz * NDotL / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportanceIBLInput(inout FSamplingState SamplingState, out vec3 LightDirection, inout float ImportanceSamplingUniformPDF, inout float ImportanceSamplingBXDFPDF)
{
    const vec2 SampleUV = Sample2DUnitQuad(SamplingState);
    const uvec2 IBLSize = textureSize(IBLTextureSampler, 0);
    uint TexelIndex = uint(IBLSize.x * IBLSize.y * SampleUV.y) + uint(IBLSize.x * SampleUV.x);

    FDeviceAliasTableEntry AliasTableEntry = IBLImportanceBuffer[TexelIndex];
    /// Get texel index
    if (RandomFloat(SamplingState) > AliasTableEntry.Threshold)
    {
        TexelIndex = AliasTableEntry.Alias;
    }

    /// Transform texel index into actual UV coordinates
    vec2 UVCoordinates = vec2((float(TexelIndex % IBLSize.x) + 0.5) / float(IBLSize.x), (float(TexelIndex / IBLSize.x) + 0.5) / float(IBLSize.y));
    /// Map them to spherical coordinates
    vec2 SphericalCoordinates = UVCoordinates * vec2(M_2_PI, M_PI);
    SphericalCoordinates.x -= M_PI_2;
    LightDirection.x = sin(SphericalCoordinates.y) * cos(SphericalCoordinates.x);
    LightDirection.y = cos(SphericalCoordinates.y);
    LightDirection.z = sin(SphericalCoordinates.y) * sin(SphericalCoordinates.x);

    float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);

    if(NDotL <= 0)
    {
        return vec4(0);
    }

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float PDF = IBLPDFBuffer[TexelIndex];
        ImportanceSamplingUniformPDF = 0.5f * M_INV_PI;
        ImportanceSamplingBXDFPDF = EvaluateScatteringPDF(Material, RayType, LightDirection);
        return vec4(texture(IBLTextureSampler, UVCoordinates).xyz * NDotL / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeBXDFIBLInput(inout FSamplingState SamplingState, vec3 LightDirection, float BXDFSamplingPDF, inout float BXDFSamplingUniformPDF, inout float BXDFSamplingImportancePDF)
{
    float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Phi = atan(RayData.Direction.z, RayData.Direction.x);
        Phi += M_PI_2;
        Phi = mod(Phi, M_2_PI);
        float Theta = asin(RayData.Direction.y);
        Phi /= M_2_PI;
        Theta /= M_PI;

        const uvec2 IBLSize = textureSize(IBLTextureSampler, 0);
        uint TexelIndex = uint(Theta * IBLSize.x * IBLSize.y) + uint(Phi * IBLSize.x);

        float PDF = BXDFSamplingPDF;
        BXDFSamplingUniformPDF = 0.5f * M_INV_PI;
        BXDFSamplingImportancePDF = IBLPDFBuffer[TexelIndex];
        return vec4(texture(IBLTextureSampler, vec2(Phi, Theta)).xyz * NDotL / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 IndexToColor(uint Value)
{
    uint ColorHash = MurMur3_32(Value, 0);
    vec4 Color = vec4(0);
    Color.x = ((ColorHash >> 24) & 0xFFu) / 255.;
    Color.y = ((ColorHash >> 18) & 0xFFu) / 255.;
    Color.z = ((ColorHash >> 12) & 0xFFu) / 255.;
    return Color;
}

void SaveAOVs(uvec2 PixelCoords, vec3 ShadingNormal, vec3 GeometricNormal, vec2 UV, vec3 WorldSpacePosition, float Opacity, float Depth, vec3 Albedo,
              vec3 Luminance, uint RenderableIndex, uint PrimitiveIndex, uint Materialindex, vec4 DebugData0, vec4 DebugData1, vec4 DebugData2, vec4 DebugData3)
{
    imageStore(ShadingNormalAOVImage, ivec2(PixelCoords), vec4((ShadingNormal + vec3(1)) * vec3(0.5), 0));
    imageStore(GeometricNormalAOVImage, ivec2(PixelCoords), vec4((GeometricNormal + vec3(1)) * vec3(0.5), 0));
    imageStore(UVAOVImage, ivec2(PixelCoords), vec4(UV, 0, 0));
    imageStore(WorldSpacePositionAOVImage, ivec2(PixelCoords), vec4(WorldSpacePosition, 0));
    imageStore(OpacityAOVImage, ivec2(PixelCoords), vec4(Opacity, Opacity, Opacity, 0));
    imageStore(DepthAOVImage, ivec2(PixelCoords), vec4(Depth, Depth, Depth, 0));
    imageStore(AlbedoAOVImage, ivec2(PixelCoords), vec4(Albedo, 0));
    imageStore(LuminanceAOVImage, ivec2(PixelCoords), vec4(Luminance, 0));

    vec4 RenderableIdColor = IndexToColor(RenderableIndex);
    imageStore(RenderableIndexAOVImage, ivec2(PixelCoords), RenderableIdColor);

    vec4 PrimitiveIdColor = IndexToColor(PrimitiveIndex);
    imageStore(PrimitiveIndexAOVImage, ivec2(PixelCoords), PrimitiveIdColor);

    vec4 MaterialIdColor = IndexToColor(Materialindex);
    imageStore(MaterialindexAOVImage, ivec2(PixelCoords), MaterialIdColor);

    imageStore(DebugLayerImage0, ivec2(PixelCoords), DebugData0);
    imageStore(DebugLayerImage1, ivec2(PixelCoords), DebugData1);
    imageStore(DebugLayerImage2, ivec2(PixelCoords), DebugData2);
    imageStore(DebugLayerImage3, ivec2(PixelCoords), DebugData3);
}

void main()
{
    /// Find actual pixel we are working with
    uint OriginalPixelIndex = MaterialsOffsets[PushConstants.MaterialIndex] + gl_LaunchIDEXT.x;
    uint PixelIndex = PixelIndexIndexMap[OriginalPixelIndex];
    uvec2 PixelCoords = uvec2(PixelIndex % PushConstants.Width, PixelIndex / PushConstants.Width);

#ifdef DEBUG_PRINTF
    if (PixelCoords.x == PushConstants.Width / 2 && PixelCoords.y == PushConstants.Height / 2 && PushConstants.BounceIndex == 0)
    {
        b = true;
        //debugPrintfEXT("Bounse: %i\n", PushConstants.BounceIndex);
    }
#endif

    /// Fetch required data
    FRayData RayData = RayDataBuffer[PixelIndex];
    FHit Hit = Hits[PixelIndex];
    FRenderable Renderable = Renderables[Hit.RenderableIndex];
    FDeviceTransform Transform = DeviceTransforms[Renderable.TransformIndex];

    ComputeShadingData(Renderable, Hit, Transform, RayData);
    float NDotI = dot(ShadingData.NormalInWorldSpace, -ShadingData.WorldSpaceIncomingDirection);
    bool bFrontFacing = true;
    float Depth = length(ShadingData.IntersectionCoordinatesInWorldSpace - RayData.Origin.xyz) * 0.0001f;

    if (NDotI < 0)
    {
        bFrontFacing = false;
        ShadingData.NormalInWorldSpace = -ShadingData.NormalInWorldSpace;
        NDotI = abs(NDotI);
    }

    /// Fetch material data
    Material = GetMaterial(ShadingData.UVCoordinates);
    /// Process material interaction
    RayType = 0u;
    FSamplingState SamplingState = FSamplingState(RenderIteration, PushConstants.BounceIndex, 0, PixelIndex, SAMPLE_TYPE_GENERATE_RAYS);
    float MaterialScatteringPDF = ScatterMaterial(Material, RayType, RayData.Eta, SamplingState, bFrontFacing);
    vec3 MaterialSamplingResult = EvaluateMaterialInteraction(Material, RayData.RayFlags);
    MaterialSamplingResult = MaterialSamplingResult * NDotI / MaterialScatteringPDF;

    vec3 CumulativeMaterialColor = CumulativeMaterialColorBuffer[PixelIndex].xyz;
    CumulativeMaterialColor *= MaterialSamplingResult.xyz;
    CumulativeMaterialColorBuffer[PixelIndex] = vec4(CumulativeMaterialColor, 1);

    RayData.Direction.xyz = ShadingData.WorldSpaceOutgoingDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace;
    RayData.RayFlags = (RayType & 0x0000FFFE) | (RayData.RayFlags & ~0x0000FFFE);

    /// Sample point light
    vec3 PointLightResult = vec3(0);
    vec3 DirectionalLightResult = vec3(0);
    vec3 SpotLightResult = vec3(0);
    vec3 IBLResult = vec3(0);
    vec3 TotalIncomingLight = vec3(0);
    SamplingState = FSamplingState(RenderIteration, PushConstants.BounceIndex, 0, PixelIndex, SAMPLE_TYPE_LIGHT);

    if (UtilityData.ActivePointLightsCount != 0)
    {
        vec4 UniformPointLightSamplingResult = vec4(0);
        vec4 ImportancePointLightSamplingResult = vec4(0);
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        float UniformSamplingImportanceSamplePDF = 0;
        float ImportanceSamplingUniformSamplePDF = 0;

        UniformPointLightSamplingResult = ComputeUniformPointLightInput(SamplingState, UtilityData.ActivePointLightsCount, UniformOutgoingDirection, UniformSamplingImportanceSamplePDF);
        ImportancePointLightSamplingResult = ComputeImportancePointLightInput(SamplingState, UtilityData.ActivePointLightsCount, ImportanceOutgoingDirection, ImportanceSamplingUniformSamplePDF);

        vec3 MaterialInteractionEvaluationResultUniformSampling = vec3(0); /// Interaction result of uniformly sampled point light and the surface
        vec3 MaterialInteractionEvaluationResultImportanceSampling = vec3(0); /// Interaction result of importance sampled point light and the surface

        float W1 = 0;
        float W2 = 0;

        if (UniformPointLightSamplingResult.w > 0.)
        {
            MaterialInteractionEvaluationResultUniformSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResultUniformSampling = MaterialInteractionEvaluationResultUniformSampling * UniformPointLightSamplingResult.xyz;
            W1 = UniformPointLightSamplingResult.w / (UniformPointLightSamplingResult.x + UniformSamplingImportanceSamplePDF);
        }

        if (ImportancePointLightSamplingResult.w > 0.)
        {
            MaterialInteractionEvaluationResultImportanceSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResultImportanceSampling = MaterialInteractionEvaluationResultImportanceSampling * ImportancePointLightSamplingResult.xyz;
            W2 = ImportancePointLightSamplingResult.w / (ImportancePointLightSamplingResult.w + ImportanceSamplingUniformSamplePDF);
        }

        PointLightResult = W1 * MaterialInteractionEvaluationResultUniformSampling + W2 * MaterialInteractionEvaluationResultImportanceSampling;
        TotalIncomingLight += UniformPointLightSamplingResult.xyz + ImportancePointLightSamplingResult.xyz;
    }

    /// Sample Directional light
    if (UtilityData.ActiveDirectionalLightsCount != 0)
    {
        vec4 UniformDirectionalLightSamplingResult = vec4(0);
        vec4 ImportanceDirectionalLightSamplingResult = vec4(0);
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        float UniformSamplingImportanceSamplePDF = 0;
        float ImportanceSamplingUniformSamplePDF = 0;

        UniformDirectionalLightSamplingResult = ComputeUniformDirectionalLightInput(SamplingState, UtilityData.ActiveDirectionalLightsCount, UniformOutgoingDirection, UniformSamplingImportanceSamplePDF);
        ImportanceDirectionalLightSamplingResult = ComputeImportanceDirectionalLightInput(SamplingState, UtilityData.ActiveDirectionalLightsCount, ImportanceOutgoingDirection, ImportanceSamplingUniformSamplePDF);

        vec3 MaterialInteractionEvaluationResultUniformSampling = vec3(0); /// Interaction result of uniformly sampled directional light and the surface
        vec3 MaterialInteractionEvaluationResultImportanceSampling = vec3(0); /// Interaction result of importance sampled directional light and the surface

        float W1 = 0;
        float W2 = 0;

        if (UniformDirectionalLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultUniformSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResultUniformSampling = MaterialInteractionEvaluationResultUniformSampling * UniformDirectionalLightSamplingResult.xyz;
            W1 = UniformDirectionalLightSamplingResult.w / (UniformDirectionalLightSamplingResult.x + UniformSamplingImportanceSamplePDF);
        }

        if (ImportanceDirectionalLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultImportanceSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResultImportanceSampling = MaterialInteractionEvaluationResultImportanceSampling * ImportanceDirectionalLightSamplingResult.xyz;
            W2 = ImportanceDirectionalLightSamplingResult.w / (ImportanceDirectionalLightSamplingResult.w + ImportanceSamplingUniformSamplePDF);
        }

        DirectionalLightResult = W1 * MaterialInteractionEvaluationResultUniformSampling + W2 * MaterialInteractionEvaluationResultImportanceSampling;
        TotalIncomingLight += UniformDirectionalLightSamplingResult.xyz + ImportanceDirectionalLightSamplingResult.xyz;
    }

    if(UtilityData.ActiveSpotLightsCount != 0)
    {
        vec4 UniformSpotLightSamplingResult = vec4(0);
        vec4 ImportanceSpotLightSamplingResult = vec4(0);
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        float UniformSamplingImportanceSamplePDF = 0;
        float ImportanceSamplingUniformSamplePDF = 0;

        UniformSpotLightSamplingResult = ComputeUniformSpotLightInput(SamplingState, UtilityData.ActiveSpotLightsCount, UniformOutgoingDirection, UniformSamplingImportanceSamplePDF);
        ImportanceSpotLightSamplingResult = ComputeImportanceSpotLightInput(SamplingState, UtilityData.ActiveSpotLightsCount, ImportanceOutgoingDirection, ImportanceSamplingUniformSamplePDF);

        vec3 MaterialInteractionEvaluationResultUniformSampling = vec3(0); /// Interaction result of uniformly sampled directional light and the surface
        vec3 MaterialInteractionEvaluationResultImportanceSampling = vec3(0); /// Interaction result of importance sampled directional light and the surface

        float W1 = 0;
        float W2 = 0;

        if (UniformSpotLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultUniformSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResultUniformSampling = MaterialInteractionEvaluationResultUniformSampling * UniformSpotLightSamplingResult.xyz;
            W1 = UniformSpotLightSamplingResult.w / (UniformSpotLightSamplingResult.x + UniformSamplingImportanceSamplePDF);
        }

        if (ImportanceSpotLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultImportanceSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResultImportanceSampling = MaterialInteractionEvaluationResultImportanceSampling * ImportanceSpotLightSamplingResult.xyz;
            W2 = ImportanceSpotLightSamplingResult.w / (ImportanceSpotLightSamplingResult.w + ImportanceSamplingUniformSamplePDF);
        }

        SpotLightResult = W1 * MaterialInteractionEvaluationResultUniformSampling + W2 * MaterialInteractionEvaluationResultImportanceSampling;
        TotalIncomingLight += UniformSpotLightSamplingResult.xyz + ImportanceSpotLightSamplingResult.xyz;
    }

    if (true /*UtilityData.IBLIsActive*/)
    {
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        vec3 BXDFOutgoingDirection = ShadingData.WorldSpaceOutgoingDirection; ///We already have bxdf direction
        float UniformSamplingImportancePDF = 0.f;
        float UniformSamplingBXDFPDF = 0.f;
        float ImportanceSamplingUniformPDF = 0.f;
        float ImportanceSamplingBXDFPDF = 0.f;
        float BXDFSamplingUniformPDF = 0.f;
        float BXDFSamplingImportancePDF = 0.f;
        float W1 = 0.f;
        float W2 = 0.f;
        float W3 = 0.f;

        vec4 UniformIBLSamplingResult = ComputeUniformIBLInput(SamplingState, UniformOutgoingDirection, UniformSamplingImportancePDF, UniformSamplingBXDFPDF);
        vec4 ImportanceIBLSamplingResult = ComputeImportanceIBLInput(SamplingState, ImportanceOutgoingDirection, ImportanceSamplingUniformPDF, ImportanceSamplingBXDFPDF);
        vec4 BXDFIBLSamplingResult = ComputeBXDFIBLInput(SamplingState, BXDFOutgoingDirection, MaterialScatteringPDF, BXDFSamplingUniformPDF, BXDFSamplingImportancePDF);

        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of uniform sampled IBL and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of importance sampled IBL and the surface
        vec3 MaterialInteractionEvaluationResult3 = vec3(0); /// Interaction result of bxdf sampled IBL and the surface

        if (UniformIBLSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResult1 = MaterialInteractionEvaluationResult1 * UniformIBLSamplingResult.xyz;
            W1 = UniformIBLSamplingResult.w / (UniformIBLSamplingResult.w + UniformSamplingImportancePDF + UniformSamplingBXDFPDF);
        }

        if (ImportanceIBLSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResult2 = MaterialInteractionEvaluationResult2 * ImportanceIBLSamplingResult.xyz;
            W2 = ImportanceIBLSamplingResult.w / (ImportanceIBLSamplingResult.w + ImportanceSamplingUniformPDF + ImportanceSamplingBXDFPDF);
        }

        if (BXDFIBLSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult3 = EvaluateMaterialInteractionFromDirection(Material, RayType, BXDFOutgoingDirection);
            MaterialInteractionEvaluationResult3 = MaterialInteractionEvaluationResult3 * BXDFIBLSamplingResult.xyz;
            W3 = BXDFIBLSamplingResult.w / (BXDFIBLSamplingResult.w + BXDFSamplingUniformPDF + BXDFSamplingImportancePDF);
        }

        IBLResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2 + W3 * MaterialInteractionEvaluationResult3;
        TotalIncomingLight += UniformIBLSamplingResult.xyz + ImportanceIBLSamplingResult.xyz + BXDFIBLSamplingResult.xyz;
    }

    vec3 BounceInput = vec3(0);
    BounceInput += PointLightResult + DirectionalLightResult + SpotLightResult + IBLResult;
    ThroughputBuffer[PixelIndex].xyz = ThroughputBuffer[PixelIndex].xyz + BounceInput;

    if ((PushConstants.BounceIndex == LAST_DIFFUSE_BOUNCE && CheckFlag(RayData.RayFlags, DIFFUSE_LAYER))
    || (PushConstants.BounceIndex == LAST_REFLECTION_BOUNCE && CheckFlag(RayData.RayFlags, SPECULAR_LAYER))
    || (PushConstants.BounceIndex == LAST_REFRACTION_BOUNCE && CheckFlag(RayData.RayFlags, TRANSMISSION_LAYER))
    || MaterialScatteringPDF <= 0.)
    {
        RayDataBuffer[PixelIndex].RayFlags = RAY_DATA_RAY_MISSED;
        imageStore(OutcomingImage, ivec2(PixelCoords), vec4(ThroughputBuffer[PixelIndex].xyz , 1));
        return;
    }

    if (PushConstants.BounceIndex == LAST_BOUNCE)
    {
        imageStore(OutcomingImage, ivec2(PixelCoords), vec4(ThroughputBuffer[PixelIndex].xyz , 1));
        return;
    }

    RayDataBuffer[PixelIndex] = RayData;
    NormalBuffer[PixelIndex] = vec4(ShadingData.NormalInWorldSpace, 1);

    if(PushConstants.BounceIndex == 0)
    {
        //DebugGlobal0 = bFrontFacing ? vec4(0.2f, 0.7f, 0.2f, 0.f) : vec4(0.7f, 0.2f, 0.2f, 0.f);
        SaveAOVs(PixelCoords, ShadingData.NormalInWorldSpace, ShadingData.NormalInWorldSpace, ShadingData.UVCoordinates, ShadingData.IntersectionCoordinatesInWorldSpace, 1., Depth,
        Material.BaseColor, TotalIncomingLight, Hit.RenderableIndex, Hit.PrimitiveIndex, PushConstants.MaterialIndex,
        DebugGlobal0, DebugGlobal1, DebugGlobal2, DebugGlobal3);
    }
}
