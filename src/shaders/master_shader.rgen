#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : enable // ?

//#define DEBUG_PRINTF
#ifdef DEBUG_PRINTF
#define DEBUG_ONLY_FIRST_BOUNCE
#extension GL_EXT_debug_printf : enable
bool b = false;
#endif

vec4 DebugGlobal0 = vec4(0);
vec4 DebugGlobal1 = vec4(0);
vec4 DebugGlobal2 = vec4(0);
vec4 DebugGlobal3 = vec4(0);

struct FShadingData
{
    /// Direction from the camera to the intersection point
    vec3 WorldSpaceIncomingDirection;
    /// Direction from the surface
    vec3 WorldSpaceOutgoingDirection;
    vec3 TangentSpaceIncomingDirection;
    vec3 TangentSpaceOutgoingDirection;
    vec3 NormalInWorldSpace;
    vec3 NormalInTangentSpace;
    vec3 IntersectionCoordinatesInWorldSpace;
    vec2 UVCoordinates;
    mat3 TNBMatrix;
    mat3 TransposedTNBMatrix;
    float MaterialScatteringPDF;
    /// cos(angle) between normal and view direction
    float NDotI;
    bool bFrontFacing;
    bool IsScatteredRaySingular;
};

#include "common_defines.h"
#include "common_structures.h"
#include "random.h"

FShadingData ShadingData;
FDeviceMaterial Material;
uint RayType;

#include "glsl_math.h"
#include "bxdf.h"
#include "process_material_interaction.h"

layout (location = 0) rayPayloadEXT FHitPayload HitPayload;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TLAS_INDEX) uniform accelerationStructureEXT TLAS;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TEXTURE_SAMPLER) uniform sampler Sampler;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TEXTURE_ARRAY) uniform texture2D Textures[MAX_TEXTURES];

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RAYS_BUFFER_INDEX) buffer RaysBufferObject
{
    FRayData RayDataBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_HITS_BUFFER_INDEX) buffer HitsBufferObject
{
    FHit Hits[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDERABLES_BUFFER_INDEX) buffer RenderablesBufferObject
{
    FRenderable Renderables[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TRANSFORMS_BUFFER_INDEX) buffer TransformsBufferObject
{
    FDeviceTransform DeviceTransforms[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_MATERIALS_OFFSETS) buffer MaterialsOffsetsBufferObject
{
    uint MaterialsOffsets[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_PIXEL_INDEX_BUFFER) buffer PixelIndexIndexMapBufferObject
{
    uint PixelIndexIndexMap[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DIRECTIONAL_LIGHTS_BUFFER_INDEX) buffer DirectionalLightsBufferObject
{
    FDirectionalLight DirectionalLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DIRECTIONAL_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer DirectionalLightsImportanceBufferObject
{
    FDeviceAliasTableEntry DirectionalLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SPOT_LIGHTS_BUFFER_INDEX) buffer SpotLightsBufferObject
{
    FSpotLight SpotLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SPOT_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer SpotLightsImportanceBufferObject
{
    FDeviceAliasTableEntry SpotLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_POINT_LIGHTS_BUFFER_INDEX) buffer PointLightsBufferObject
{
    FPointLight PointLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_POINT_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer PointLightsImportanceBufferObject
{
    FDeviceAliasTableEntry PointLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_AREA_LIGHTS_BUFFER_INDEX) buffer AreaLightsBufferObject
{
    FAreaLight AreaLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_AREA_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer AreaLightsImportanceBufferObject
{
    FDeviceAliasTableEntry AreaLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_IMPORTANCE_BUFFER_INDEX) buffer IBLImportanceBufferObject
{
    FDeviceAliasTableEntry IBLImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_IMAGE_SAMPLER_INDEX) uniform sampler2D IBLTextureSampler;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_WEIGHTS_BUFFER_INDEX) buffer IBLPDFBufferObject
{
    float IBLPDFBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_UTILITY_BUFFER_INDEX) uniform UtilityDataUniformBufferObject
{
    FUtilityData UtilityData;
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDER_ITERATION_BUFFER_INDEX) buffer RenderIterationBufferObject
{
    uint RenderIteration;
};

/// TODO: Rename this buffer
layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_CUMULATIVE_MATERIAL_COLOR_BUFFER_INDEX) buffer CumulativeMaterialColorBufferObject
{
    vec4 CumulativeMaterialColorBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_NORMAL_BUFFER) buffer NormalBufferObject
{
    vec4 NormalBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_THROUGHPUT_BUFFER) buffer ThroughputBufferObject
{
    vec4 ThroughputBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_COLOR_AOV_IMAGE_INDEX, rgba32f) uniform image2D OutcomingImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SHADING_NORMAL_AOV_IMAGE_INDEX, rgba32f) uniform image2D ShadingNormalAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_GEOMETRIC_NORMAL_AOV_IMAGE_INDEX, rgba32f) uniform image2D GeometricNormalAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_UV_AOV_IMAGE_INDEX, rg32f) uniform image2D UVAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_WORLD_SPACE_POSITION_AOV_IMAGE_INDEX, rgba32f) uniform image2D WorldSpacePositionAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_OPACITY_AOV_IMAGE_INDEX, rgba32f) uniform image2D OpacityAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEPTH_AOV_IMAGE_INDEX, rgba32f) uniform image2D DepthAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_ALBEDO_AOV_IMAGE_INDEX, rgba32f) uniform image2D AlbedoAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_LUMINANCE_AOV_IMAGE_INDEX, rgba32f) uniform image2D LuminanceAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDERABLE_INDEX_IMAGE_INDEX, rgba32f) uniform image2D RenderableIndexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_PRIMITIVE_INDEX_IMAGE_INDEX, rgba32f) uniform image2D PrimitiveIndexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_MATERIAL_INDEX_IMAGE_INDEX, rgba32f) uniform image2D MaterialindexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_0_INDEX, rgba32f) uniform image2D DebugLayerImage0;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_1_INDEX, rgba32f) uniform image2D DebugLayerImage1;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_2_INDEX, rgba32f) uniform image2D DebugLayerImage2;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_3_INDEX, rgba32f) uniform image2D DebugLayerImage3;

layout (buffer_reference, scalar) buffer Vertices
{
    FDeviceVertex V[];
};

layout (buffer_reference, scalar) buffer Indices
{
    int I[];
};

layout (buffer_reference, scalar) buffer AreaLightsAliasTableReference
{
    FDeviceAliasTableEntry T[];
};

layout (push_constant) uniform PushConstantsBlock
{
    FPushConstants PushConstants;
};

bool CheckFlag(uint Mask, uint Field)
{
    return (Mask & Field) == Field;
}

bool IsIndexed(FRenderable Renderable)
{
    return CheckFlag(Renderable.RenderablePropertyMask, RENDERABLE_IS_INDEXED);
}

FVertex UnpackDeviceVertex(FDeviceVertex DV)
{
    FVertex V;
    V.Position.x = DV.A.x;
    V.Position.y = DV.A.y;
    V.Position.z = DV.A.z;
    V.Normal.x = DV.A.w;
    V.Normal.y = DV.B.x;
    V.Normal.z = DV.B.y;
    V.TexCoord.x = DV.B.z;
    V.TexCoord.y = DV.B.w;
    return V;
}

vec3 SampleVec3(uint TextureIndex, vec2 TextureCoords)
{
    return texture(sampler2D(Textures[TextureIndex], Sampler), TextureCoords).rgb;
}

float SampleFloat(uint TextureIndex, vec2 TextureCoords)
{
    return texture(sampler2D(Textures[TextureIndex], Sampler), TextureCoords).r;
}

FDeviceMaterial GetMaterial(vec2 TextureCoords);
FDeviceMaterial GetEmissiveMaterial(vec2 TextureCoords, uint MaterialIndex);

void ComputeShadingData(FRenderable Renderable, FHit Hit, FDeviceTransform Transform, FRayData RayData)
{
    Vertices Verts = Vertices(Renderable.VertexBufferAddress);
    Indices Inds = Indices(Renderable.IndexBufferAddress);
    vec3 Barycentrics = vec3(1.0 - Hit.HitUV.x - Hit.HitUV.y, Hit.HitUV.x, Hit.HitUV.y);

    FDeviceVertex DV0;
    FDeviceVertex DV1;
    FDeviceVertex DV2;

    if (IsIndexed(Renderable))
    {
        uint I0 = 0;
        uint I1 = 1;
        uint I2 = 2;

        I0 = Inds.I[Hit.PrimitiveIndex * 3];
        I1 = Inds.I[Hit.PrimitiveIndex * 3 + 1];
        I2 = Inds.I[Hit.PrimitiveIndex * 3 + 2];

        DV0 = Verts.V[I0];
        DV1 = Verts.V[I1];
        DV2 = Verts.V[I2];
    }
    else
    {
        uint Index = Hit.PrimitiveIndex * 3;
        DV0 = Verts.V[Index];
        DV1 = Verts.V[Index + 1];
        DV2 = Verts.V[Index + 2];
    }

    FVertex V0 = UnpackDeviceVertex(DV0);
    FVertex V1 = UnpackDeviceVertex(DV1);
    FVertex V2 = UnpackDeviceVertex(DV2);

    ShadingData.WorldSpaceIncomingDirection = RayData.Direction.xyz;

    ShadingData.NormalInWorldSpace = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
    /// Pay more attention to why vector * matrix, and not vice versa
    ShadingData.NormalInWorldSpace = ShadingData.NormalInWorldSpace * mat3(Transform.InverseModelMatrix);
    ShadingData.NormalInWorldSpace = normalize(ShadingData.NormalInWorldSpace);

    /// -ShadingData.WorldSpaceIncomingDirection Because we need a direction from the intersection point
    ShadingData.NDotI = dot(ShadingData.NormalInWorldSpace, -ShadingData.WorldSpaceIncomingDirection);

    /// Invert normal if it's facing backwards
    if (ShadingData.NDotI < 0)
    {
        ShadingData.bFrontFacing = false;
        ShadingData.NormalInWorldSpace = -ShadingData.NormalInWorldSpace;
        ShadingData.NDotI = abs(ShadingData.NDotI);
    }
    else
    {
        ShadingData.bFrontFacing = true;
    }

    ShadingData.TNBMatrix = CreateTNBMatrix(ShadingData.NormalInWorldSpace);
    ShadingData.TransposedTNBMatrix = transpose(ShadingData.TNBMatrix);

    ShadingData.WorldSpaceIncomingDirection = RayData.Direction.xyz;
    ShadingData.TangentSpaceIncomingDirection = ShadingData.WorldSpaceIncomingDirection * ShadingData.TNBMatrix;

    ShadingData.IntersectionCoordinatesInWorldSpace = V0.Position * Barycentrics.x + V1.Position * Barycentrics.y + V2.Position * Barycentrics.z;
    ShadingData.IntersectionCoordinatesInWorldSpace = vec3(vec4(ShadingData.IntersectionCoordinatesInWorldSpace, 1.f) * Transform.ModelMatrix);

    /// TODO: Can Hit.HitUV just be used?
    ShadingData.UVCoordinates = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;
}

vec4 ComputeUniformPointLightInput(inout FSamplingState SamplingState, uint PointLightsCount, out vec3 Direction, inout float ImportanceSamplingPDF)
{
    /// Get light index
    const uint LightIndex = uint(RandomFloat(SamplingState) * PointLightsCount);
    FPointLight PointLightUniform = PointLightsBuffer[LightIndex];
    Direction = PointLightUniform.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;
        /// Here, the probability of sampling a particular point light is one to the number of point lights
        ImportanceSamplingPDF = PointLightUniform.Power / UtilityData.TotalPointLightPower;
        return vec4(PointLightUniform.Color * PointLightUniform.Intensity * Attenuation * NDotI * PointLightsCount, 1.f / PointLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportancePointLightInput(inout FSamplingState SamplingState, uint PointLightsCount, out vec3 Direction, inout float UniformSamplingPDF)
{
    /// Get light index by importance sampling it
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * PointLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = PointLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FPointLight PointLightImportance = PointLightsBuffer[ImportanceLightIndex];

    Direction = PointLightImportance.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;
        /// Here, the probability of sampling a particular point light depends on it's power and total power of all lights
        float PDF = PointLightImportance.Power / UtilityData.TotalPointLightPower;
        UniformSamplingPDF = 1.f / PointLightsCount;
        return vec4(PointLightImportance.Color * PointLightImportance.Intensity * Attenuation * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformDirectionalLightInput(inout FSamplingState SamplingState, uint DirectionalLightsCount, out vec3 Direction, inout float ImportanceSamplingPDF)
{
    /// Get light index by uniformly sampling it
    const uint LightIndex = uint(RandomFloat(SamplingState) * DirectionalLightsCount);
    FDirectionalLight DirectionalLight = DirectionalLightsBuffer[LightIndex];

    /// Check whether light is over the surface
    Direction = -DirectionalLight.Direction;
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        /// Here, the probability of sampling a particular directional light is one to the number of directional lights
        ImportanceSamplingPDF = DirectionalLight.Power / UtilityData.TotalDirectionalLightPower;
        return vec4(DirectionalLight.Color * DirectionalLight.Intensity * NDotI * DirectionalLightsCount, 1.f / DirectionalLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

/// Sample a directional light by it's power
vec4 ComputeImportanceDirectionalLightInput(inout FSamplingState SamplingState, uint DirectionalLightsCount, out vec3 Direction, inout float UniformSamplingPDF)
{
    /// Get light index by importance sampling it
    uint LightIndex = uint(RandomFloat(SamplingState) * DirectionalLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = DirectionalLightsImportanceBuffer[LightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        LightIndex = ImportanceSampleTableEntry.Alias;
    }

    FDirectionalLight DirectionalLight = DirectionalLightsBuffer[LightIndex];

    Direction = -DirectionalLight.Direction;

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        /// Here, the probability of sampling a particular directional light is it's power to the total power of all directional light
        float PDF = DirectionalLight.Power / UtilityData.TotalDirectionalLightPower;
        UniformSamplingPDF = 1.f / DirectionalLightsCount;
        return vec4(DirectionalLight.Color * DirectionalLight.Intensity * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformSpotLightInput(inout FSamplingState SamplingState, uint SpotLightsCount, out vec3 Direction, inout float ImportanceSamplingPDF)
{
    /// Get light index
    const uint LightIndex = uint(RandomFloat(SamplingState) * SpotLightsCount);
    FSpotLight SpotLight = SpotLightsBuffer[LightIndex];
    Direction = SpotLight.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    float LightAngle = acos(dot(SpotLight.Direction, -Direction));
    /// If point is outside out outer angle, it is also not illuminated
    if (LightAngle > SpotLight.OuterAngle)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;

        /// If point between outer and inner angle - interpolate
        if (LightAngle > SpotLight.InnerAngle)
        {
            float Fraction = LightAngle - SpotLight.InnerAngle;
            float Delta = SpotLight.OuterAngle - SpotLight.InnerAngle;
            Fraction = Fraction / Delta;
            Attenuation *= pow((1. - Fraction), 2.4);
        }

        /// Here, the probability of sampling a particular spot light is one to the number of spot lights
        ImportanceSamplingPDF = SpotLight.Power / UtilityData.TotalSpotLightPower;
        return vec4(SpotLight.Color * SpotLight.Intensity * Attenuation * NDotI * SpotLightsCount, 1.f / SpotLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportanceSpotLightInput(inout FSamplingState SamplingState, uint SpotLightsCount, out vec3 Direction, inout float UniformSamplingPDF)
{
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * SpotLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = SpotLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FSpotLight SpotLightImportance = SpotLightsBuffer[ImportanceLightIndex];

    Direction = SpotLightImportance.Position - ShadingData.IntersectionCoordinatesInWorldSpace;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(ShadingData.NormalInWorldSpace, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    float LightAngle = acos(dot(SpotLightImportance.Direction, -Direction));
    /// If point is outside out outer angle, it is also not illuminated
    if (LightAngle > SpotLightImportance.OuterAngle)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;

        /// If point between outer and inner angle - interpolate
        if (LightAngle > SpotLightImportance.InnerAngle)
        {
            float Fraction = LightAngle - SpotLightImportance.InnerAngle;
            float Delta = SpotLightImportance.OuterAngle - SpotLightImportance.InnerAngle;
            Fraction = Fraction / Delta;
            Attenuation *= pow((1. - Fraction), 2.4);
        }

        /// Here, the probability of sampling a particular spot light is dependent on the spot light's power and total spot lights power
        float PDF = SpotLightImportance.Power / UtilityData.TotalSpotLightPower;
        UniformSamplingPDF = 1.f / SpotLightsCount;
        return vec4(SpotLightImportance.Color * SpotLightImportance.Intensity * Attenuation * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformAreaLightInput(inout FSamplingState SamplingState, out vec3 LightDirection, inout float UniformSamplingImportancePDF, inout float UniformSamplingBXDFPDF)
{
    /// First - select an area light at random (uniformly)
    uint UniformLightIndex = uint(RandomFloat(SamplingState) * UtilityData.ActiveAreaLightsCount);

    FAreaLight ArealLight = AreaLightsBuffer[UniformLightIndex];

    /// Second - select a triangle within area light at random (also uniformly)
    uint UniformTriangleIndex = uint(RandomFloat(SamplingState) * ArealLight.NumberOfTriangles);

    /// Get that random triangle from the mesh that is marked as area light
    Vertices Verts = Vertices(ArealLight.VertexBufferAddress);
    Indices Inds = Indices(ArealLight.IndexBufferAddress);
    bool RenderableIsIndexed = (ArealLight.IsIndexedFlagAndRenderableIndex & 0x80000000) == 0x80000000;
    uint RenderableIndex = ArealLight.IsIndexedFlagAndRenderableIndex & 0x7FFFFFFF;

    FDeviceVertex DV0;
    FDeviceVertex DV1;
    FDeviceVertex DV2;

    if (RenderableIsIndexed)
    {
        uint I0 = 0;
        uint I1 = 1;
        uint I2 = 2;

        I0 = Inds.I[UniformTriangleIndex * 3];
        I1 = Inds.I[UniformTriangleIndex * 3 + 1];
        I2 = Inds.I[UniformTriangleIndex * 3 + 2];

        DV0 = Verts.V[I0];
        DV1 = Verts.V[I1];
        DV2 = Verts.V[I2];
    }
    else
    {
        uint Index = UniformTriangleIndex * 3;
        DV0 = Verts.V[Index];
        DV1 = Verts.V[Index + 1];
        DV2 = Verts.V[Index + 2];
    }

    /// Unpack data
    FVertex V0 = UnpackDeviceVertex(DV0);
    FVertex V1 = UnpackDeviceVertex(DV1);
    FVertex V2 = UnpackDeviceVertex(DV2);

    /// Sample random point on that triangle
    vec2 RandomVec2 = Sample2DUnitQuad(SamplingState);

    /// Without this, RandomPoint will be placed in parallelogram denoted by the triangle
    if (RandomVec2.x + RandomVec2.y > 1.)
    {
        RandomVec2.x = 1. - RandomVec2.x;
        RandomVec2.y = 1. - RandomVec2.y;
    }

    vec3 V0V1Direction = V1.Position - V0.Position;
    vec3 V0V2Direction = V2.Position - V0.Position;
    float TriangleArea = 0.5f * length(cross(V0V1Direction, V0V2Direction));
    /// Get RandomPoint in local space
    vec3 RandomPoint = V0.Position + V0V1Direction * RandomVec2.x + V0V2Direction * RandomVec2.y;

    /// Transform point into world-space
    FDeviceTransform Transform = DeviceTransforms[ArealLight.TransformIndex];
    RandomPoint = vec3(vec4(RandomPoint, 1.f) * Transform.ModelMatrix);
    /// A direction to light
    LightDirection = RandomPoint - ShadingData.IntersectionCoordinatesInWorldSpace;
    float Distance2 = dot(LightDirection, LightDirection);
    LightDirection = normalize(LightDirection);

    /// Check whether light is over the surface
    float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);

    if(NDotL <= 0)
    {
        /// Light is on the other side
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we did hit a required triange, then we store light data
    if (HitPayload.PrimitiveIndex == UniformTriangleIndex && HitPayload.RenderableIndex == RenderableIndex)
    {
        vec3 Barycentrics = vec3(1.f - HitPayload.HitUV.x - HitPayload.HitUV.y, HitPayload.HitUV.x, HitPayload.HitUV.y);

        /// Compute UV
        vec2 UV = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;
        /// Compute normal
        vec3 AreaLightTriangleNormal = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
        AreaLightTriangleNormal = AreaLightTriangleNormal * mat3(Transform.InverseModelMatrix);
        AreaLightTriangleNormal = normalize(AreaLightTriangleNormal);
        float NDotI = abs(dot(AreaLightTriangleNormal, LightDirection));

        /// Get the material
        FDeviceMaterial EmissiveMaterial = GetEmissiveMaterial(UV, ArealLight.MaterialIndex);
        /// TODO: Is this a correct PDF formula?
        float PDF = Distance2 / (UtilityData.ActiveAreaLightsCount * ArealLight.NumberOfTriangles * TriangleArea * NDotI);
        UniformSamplingImportancePDF = Distance2 / (UtilityData.TotalAreaLightArea * NDotI);
        UniformSamplingBXDFPDF = EvaluateScatteringPDF(Material, RayType, LightDirection);

        return vec4(EmissiveMaterial.EmissionColor * NDotL / PDF, PDF);
    }
    else
    {
        /// Something ocludded the light
        return vec4(0);
    }
}

vec4 ComputeImportanceAreaLightInput(inout FSamplingState SamplingState, out vec3 LightDirection, inout float ImportanceSamplingUniformPDF, inout float ImportanceSamplingBXDFPDF)
{
    /// First - select and area light based on it's area
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * UtilityData.ActiveAreaLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = AreaLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FAreaLight ArealLightImportance = AreaLightsBuffer[ImportanceLightIndex];

    /// Second - select a triangle within area light based on it's area
    uint ImportanceTriangleIndex = uint(RandomFloat(SamplingState) * ArealLightImportance.NumberOfTriangles);
    AreaLightsAliasTableReference AreaLightAliasTable = AreaLightsAliasTableReference(ArealLightImportance.AliasTableBufferAddress);

    ImportanceSampleTableEntry = AreaLightAliasTable.T[ImportanceTriangleIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceTriangleIndex = ImportanceSampleTableEntry.Alias;
    }

    /// Get that random triangle from the mesh that is marked as area light
    Vertices Verts = Vertices(ArealLightImportance.VertexBufferAddress);
    Indices Inds = Indices(ArealLightImportance.IndexBufferAddress);
    bool RenderableIsIndexed = (ArealLightImportance.IsIndexedFlagAndRenderableIndex & 0x80000000) == 0x80000000;
    uint RenderableIndex = ArealLightImportance.IsIndexedFlagAndRenderableIndex & 0x7FFFFFFF;

    FDeviceVertex DV0;
    FDeviceVertex DV1;
    FDeviceVertex DV2;

    if (RenderableIsIndexed)
    {
        uint I0 = 0;
        uint I1 = 1;
        uint I2 = 2;

        I0 = Inds.I[ImportanceTriangleIndex * 3];
        I1 = Inds.I[ImportanceTriangleIndex * 3 + 1];
        I2 = Inds.I[ImportanceTriangleIndex * 3 + 2];

        DV0 = Verts.V[I0];
        DV1 = Verts.V[I1];
        DV2 = Verts.V[I2];
    }
    else
    {
        uint Index = ImportanceTriangleIndex * 3;
        DV0 = Verts.V[Index];
        DV1 = Verts.V[Index + 1];
        DV2 = Verts.V[Index + 2];
    }

    /// Unpack data
    FVertex V0 = UnpackDeviceVertex(DV0);
    FVertex V1 = UnpackDeviceVertex(DV1);
    FVertex V2 = UnpackDeviceVertex(DV2);

    /// Sample random point on that triangle
    vec2 RandomVec2 = Sample2DUnitQuad(SamplingState);

    /// Without this, RandomPoint will be placed in parallelogram denoted by the triangle
    if (RandomVec2.x + RandomVec2.y > 1.)
    {
        RandomVec2.x = 1. - RandomVec2.x;
        RandomVec2.y = 1. - RandomVec2.y;
    }

    vec3 V0V1Direction = V1.Position - V0.Position;
    vec3 V0V2Direction = V2.Position - V0.Position;
    float TriangleArea = 0.5f * length(cross(V0V1Direction, V0V2Direction));
    /// Get RandomPoint in local space
    vec3 RandomPoint = V0.Position + V0V1Direction * RandomVec2.x + V0V2Direction * RandomVec2.y;

    /// Transform point into world-space
    FDeviceTransform Transform = DeviceTransforms[ArealLightImportance.TransformIndex];
    RandomPoint = vec3(vec4(RandomPoint, 1.f) * Transform.ModelMatrix);
    /// A direction to light
    LightDirection = RandomPoint - ShadingData.IntersectionCoordinatesInWorldSpace;
    float Distance2 = dot(LightDirection, LightDirection);
    LightDirection = normalize(LightDirection);

    /// Check whether light is over the surface
    float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);

    if(NDotL <= 0)
    {
        /// Light is on the other side
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we did hit a required triange, then we store light data
    if (HitPayload.PrimitiveIndex == ImportanceTriangleIndex && HitPayload.RenderableIndex == RenderableIndex)
    {
        vec3 Barycentrics = vec3(1.f - HitPayload.HitUV.x - HitPayload.HitUV.y, HitPayload.HitUV.x, HitPayload.HitUV.y);

        /// Compute UV
        vec2 UV = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;
        /// Compute normal
        vec3 AreaLightTriangleNormal = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
        AreaLightTriangleNormal = AreaLightTriangleNormal * mat3(Transform.InverseModelMatrix);
        AreaLightTriangleNormal = normalize(AreaLightTriangleNormal);
        float NDotI = abs(dot(AreaLightTriangleNormal, LightDirection));

        /// Get the material
        FDeviceMaterial EmissiveMaterial = GetEmissiveMaterial(UV, ArealLightImportance.MaterialIndex);
        /// TODO: Is this a correct PDF formula?
        float PDF = Distance2 / (UtilityData.TotalAreaLightArea * NDotI);
        ImportanceSamplingUniformPDF = Distance2 / (UtilityData.ActiveAreaLightsCount * ArealLightImportance.NumberOfTriangles * TriangleArea * NDotI);
        ImportanceSamplingBXDFPDF = EvaluateScatteringPDF(Material, RayType, LightDirection);

        return vec4(EmissiveMaterial.EmissionColor * NDotL / PDF, PDF);
    }
    else
    {
        /// Something ocludded the light
        return vec4(0);
    }
}

vec4 ComputeBXDFAreaLightInput(inout FSamplingState SamplingState, vec3 LightDirection, float BXDFPDF, inout float BXDFSamplingUniformPDF, inout float BXDFSamplingImportancePDF)
{
    /// Construct a shadow ray
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    /// TODO: Utilize gl_HitTEXT in hit shader
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// If we hit any geometry, let's check whether it's an emissive
    if (HitPayload.RenderableIndex != UINT_MAX)
    {
        FRenderable Renderable = Renderables[HitPayload.RenderableIndex];
        /// TODO: Add a flag to renderable to skipp all those computations if renderable is not emissive
        Vertices Verts = Vertices(Renderable.VertexBufferAddress);
        Indices Inds = Indices(Renderable.IndexBufferAddress);

        FDeviceVertex DV0;
        FDeviceVertex DV1;
        FDeviceVertex DV2;

        if (IsIndexed(Renderable))
        {
            uint I0 = 0;
            uint I1 = 1;
            uint I2 = 2;

            I0 = Inds.I[HitPayload.PrimitiveIndex * 3];
            I1 = Inds.I[HitPayload.PrimitiveIndex * 3 + 1];
            I2 = Inds.I[HitPayload.PrimitiveIndex * 3 + 2];

            DV0 = Verts.V[I0];
            DV1 = Verts.V[I1];
            DV2 = Verts.V[I2];
        }
        else
        {
            uint Index = HitPayload.PrimitiveIndex * 3;
            DV0 = Verts.V[Index];
            DV1 = Verts.V[Index + 1];
            DV2 = Verts.V[Index + 2];
        }

        /// Unpack data
        FVertex V0 = UnpackDeviceVertex(DV0);
        FVertex V1 = UnpackDeviceVertex(DV1);
        FVertex V2 = UnpackDeviceVertex(DV2);

        vec3 Barycentrics = vec3(1.0 - HitPayload.HitUV.x - HitPayload.HitUV.y, HitPayload.HitUV.x, HitPayload.HitUV.y);
        vec2 TextureCoords = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;

        /// TODO: Optimize
        FDeviceMaterial EmissiveMaterial = GetEmissiveMaterial(TextureCoords, Renderable.MaterialIndex);

        if (EmissiveMaterial.EmissionWeight != 0)
        {
            FDeviceTransform Transform = DeviceTransforms[Renderable.TransformIndex];

            vec3 EmissiveNormalInWorldSpace = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
            /// Pay more attention to why vector * matrix, and not vice versa
            EmissiveNormalInWorldSpace = EmissiveNormalInWorldSpace * mat3(Transform.InverseModelMatrix);
            EmissiveNormalInWorldSpace = normalize(EmissiveNormalInWorldSpace);

            /// This is the cosine of the angle betweeen the emissive triangle's normal and a shadow ray direction
            /// Why do we take the abs? Because the shadow ray is have to be on the correct side of the hemisphere and
            /// we don't have two sided materials, so emissive emmits on both sides
            float NDotL = abs(dot(EmissiveNormalInWorldSpace, RayData.Direction.xyz));

            uint AreaLightIndex = Renderable.RenderablePropertyMask & RENDERABLE_AREA_LIGHT_INDEX_MASK;
            FAreaLight ArealLight = AreaLightsBuffer[AreaLightIndex];

            vec3 WorldSpaceIntersectionCoordinates = V0.Position * Barycentrics.x + V1.Position * Barycentrics.y + V2.Position * Barycentrics.z;
            WorldSpaceIntersectionCoordinates = vec3(vec4(WorldSpaceIntersectionCoordinates, 1.f) * Transform.ModelMatrix);
            float Distance2 = dot(WorldSpaceIntersectionCoordinates - RayData.Origin.xyz, WorldSpaceIntersectionCoordinates - RayData.Origin.xyz);
            vec3 P0 = vec3(vec4(V0.Position, 1.f) * Transform.ModelMatrix);
            vec3 P1 = vec3(vec4(V1.Position, 1.f) * Transform.ModelMatrix);
            vec3 P2 = vec3(vec4(V2.Position, 1.f) * Transform.ModelMatrix);
            float TriangleArea = 0.5f * length(cross(P1 - P0, P2 - P0));

            float PDF = BXDFPDF;
            BXDFSamplingUniformPDF = Distance2 / (UtilityData.ActiveAreaLightsCount * ArealLight.NumberOfTriangles * TriangleArea * NDotL);
            BXDFSamplingImportancePDF = Distance2 / (UtilityData.TotalAreaLightArea * NDotL);
            return vec4(EmissiveMaterial.EmissionColor * ShadingData.NDotI / PDF, PDF);
        }
    }

    return vec4(0);
}

vec4 ComputeUniformIBLInput(inout FSamplingState SamplingState, out vec3 LightDirection, inout float UniformSamplingImportancePDF, inout float UniformSamplingBXDFPDF)
{
    /// TODO: Verify that sampling is uniform
    /// Sample a random direction in the hemisphere and transform it into world-space coordinate system
    LightDirection = Sample3DUnitHemisphere(SamplingState) * ShadingData.TransposedTNBMatrix;

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        const uvec2 IBLSize = textureSize(IBLTextureSampler, 0);
        vec2 IBLUV = Vec3ToSphericalUV(ShadingData.WorldSpaceOutgoingDirection, M_PI_2);
        uint TexelIndex = uint(IBLUV.y * IBLSize.x * IBLSize.y) + uint(IBLUV.x * IBLSize.x);

        float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);
        float PDF = 0.5f * M_INV_PI;
        UniformSamplingImportancePDF = IBLPDFBuffer[TexelIndex];
        UniformSamplingBXDFPDF = EvaluateScatteringPDF(Material, RayType, LightDirection);
        return vec4(texture(IBLTextureSampler, IBLUV).xyz * NDotL / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportanceIBLInput(inout FSamplingState SamplingState, out vec3 LightDirection, inout float ImportanceSamplingUniformPDF, inout float ImportanceSamplingBXDFPDF)
{
    vec2 UVCoordinates = Sample2DUnitQuad(SamplingState);
    const uvec2 IBLSize = textureSize(IBLTextureSampler, 0);
    uint TexelIndex = uint(IBLSize.x * IBLSize.y * UVCoordinates.y) + uint(IBLSize.x * UVCoordinates.x);

    FDeviceAliasTableEntry AliasTableEntry = IBLImportanceBuffer[TexelIndex];
    /// Get texel index
    if (RandomFloat(SamplingState) > AliasTableEntry.Threshold)
    {
        TexelIndex = AliasTableEntry.Alias;
        /// Transform texel index into actual UV coordinates
        UVCoordinates = vec2((float(TexelIndex % IBLSize.x) + 0.5) / float(IBLSize.x), (float(TexelIndex / IBLSize.x) + 0.5) / float(IBLSize.y));
    }

    /// Map UV coordinates to spherical coordinates
    vec2 SphericalCoordinates = UVCoordinates * vec2(M_2_PI, M_PI);
    SphericalCoordinates.x -= M_PI_2;
    LightDirection.x = sin(SphericalCoordinates.y) * cos(SphericalCoordinates.x);
    LightDirection.y = cos(SphericalCoordinates.y);
    LightDirection.z = sin(SphericalCoordinates.y) * sin(SphericalCoordinates.x);

    float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);

    if(NDotL <= 0)
    {
        return vec4(0);
    }

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float PDF = IBLPDFBuffer[TexelIndex] * IBLSize.x * IBLSize.y;
        ImportanceSamplingUniformPDF = 0.5f * M_INV_PI;
        ImportanceSamplingBXDFPDF = EvaluateScatteringPDF(Material, RayType, LightDirection);
        return vec4(texture(IBLTextureSampler, UVCoordinates).xyz * NDotL / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeBXDFIBLInput(inout FSamplingState SamplingState, vec3 LightDirection, float BXDFSamplingPDF, inout float BXDFSamplingUniformPDF, inout float BXDFSamplingImportancePDF)
{
    float NDotL = dot(ShadingData.NormalInWorldSpace, LightDirection);

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace + ShadingData.NormalInWorldSpace * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        const uvec2 IBLSize = textureSize(IBLTextureSampler, 0);
        vec2 IBLUV = Vec3ToSphericalUV(ShadingData.WorldSpaceOutgoingDirection, M_PI_2);
        uint TexelIndex = uint(IBLUV.y * IBLSize.x * IBLSize.y) + uint(IBLUV.x * IBLSize.x);

        float PDF = BXDFSamplingPDF;
        BXDFSamplingUniformPDF = 0.5f * M_INV_PI;
        BXDFSamplingImportancePDF = IBLPDFBuffer[TexelIndex];
        return vec4(texture(IBLTextureSampler, IBLUV).xyz * NDotL / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 IndexToColor(uint Value)
{
    uint ColorHash = MurMur3_32(Value, 0);
    vec4 Color = vec4(0);
    Color.x = ((ColorHash >> 24) & 0xFFu) / 255.;
    Color.y = ((ColorHash >> 18) & 0xFFu) / 255.;
    Color.z = ((ColorHash >> 12) & 0xFFu) / 255.;
    return Color;
}

void SaveAOVs(uvec2 PixelCoords, vec3 ShadingNormal, vec3 GeometricNormal, vec2 UV, vec3 WorldSpacePosition, float Opacity, float Depth, vec3 Albedo,
              vec3 Luminance, uint RenderableIndex, uint PrimitiveIndex, uint Materialindex, vec4 DebugData0, vec4 DebugData1, vec4 DebugData2, vec4 DebugData3)
{
    imageStore(ShadingNormalAOVImage, ivec2(PixelCoords), vec4((ShadingNormal + vec3(1)) * vec3(0.5), 0));
    imageStore(GeometricNormalAOVImage, ivec2(PixelCoords), vec4((GeometricNormal + vec3(1)) * vec3(0.5), 0));
    imageStore(UVAOVImage, ivec2(PixelCoords), vec4(UV, 0, 0));
    imageStore(WorldSpacePositionAOVImage, ivec2(PixelCoords), vec4(WorldSpacePosition, 0));
    imageStore(OpacityAOVImage, ivec2(PixelCoords), vec4(Opacity, Opacity, Opacity, 0));
    imageStore(DepthAOVImage, ivec2(PixelCoords), vec4(Depth, Depth, Depth, 0));
    imageStore(AlbedoAOVImage, ivec2(PixelCoords), vec4(Albedo, 0));
    imageStore(LuminanceAOVImage, ivec2(PixelCoords), vec4(Luminance, 0));

    vec4 RenderableIdColor = IndexToColor(RenderableIndex);
    imageStore(RenderableIndexAOVImage, ivec2(PixelCoords), RenderableIdColor);

    vec4 PrimitiveIdColor = IndexToColor(PrimitiveIndex);
    imageStore(PrimitiveIndexAOVImage, ivec2(PixelCoords), PrimitiveIdColor);

    vec4 MaterialIdColor = IndexToColor(Materialindex);
    imageStore(MaterialindexAOVImage, ivec2(PixelCoords), MaterialIdColor);

    imageStore(DebugLayerImage0, ivec2(PixelCoords), DebugData0);
    imageStore(DebugLayerImage1, ivec2(PixelCoords), DebugData1);
    imageStore(DebugLayerImage2, ivec2(PixelCoords), DebugData2);
    imageStore(DebugLayerImage3, ivec2(PixelCoords), DebugData3);
}

void main()
{
    /// Find actual pixel we are working with
    uint OriginalPixelIndex = MaterialsOffsets[PushConstants.MaterialIndex] + gl_LaunchIDEXT.x;
    uint PixelIndex = PixelIndexIndexMap[OriginalPixelIndex];
    uvec2 PixelCoords = uvec2(PixelIndex % PushConstants.Width, PixelIndex / PushConstants.Width);

#ifdef DEBUG_PRINTF
    if (PixelCoords.x == PushConstants.Width / 2 && PixelCoords.y == PushConstants.Height / 2)
    {
        b = true;
        //debugPrintfEXT("Bounse: %i\n", PushConstants.BounceIndex);
    }
#endif

#ifdef DEBUG_ONLY_FIRST_BOUNCE
    if (PushConstants.BounceIndex != 0)
    {
        b = false;
    }
#endif

    /// Fetch required data
    FRayData RayData = RayDataBuffer[PixelIndex];
    FHit Hit = Hits[PixelIndex];
    FRenderable Renderable = Renderables[Hit.RenderableIndex];
    FDeviceTransform Transform = DeviceTransforms[Renderable.TransformIndex];
    ComputeShadingData(Renderable, Hit, Transform, RayData);
    float Depth = length(ShadingData.IntersectionCoordinatesInWorldSpace - RayData.Origin.xyz) * 0.0001f;

    /// Fetch material data
    Material = GetMaterial(ShadingData.UVCoordinates);
    /// Process material interaction
    RayType = 0u;
    FSamplingState SamplingState = FSamplingState(RenderIteration, PushConstants.BounceIndex, 0, PixelIndex, SAMPLE_TYPE_GENERATE_RAYS);
    ShadingData.MaterialScatteringPDF = ScatterMaterial(Material, RayType, RayData.Eta, SamplingState, ShadingData.bFrontFacing);

    /// If we hit emissive material on the first hit, just output it, nothing else to do here
    if (PushConstants.BounceIndex == 0 && RayType == EMISSION_LAYER)
    {
        RayDataBuffer[PixelIndex].RayFlags = RAY_DATA_RAY_MISSED;
        imageStore(OutcomingImage, ivec2(PixelCoords), vec4(Material.EmissionColor , 1));
        return;
    }

    vec3 BxDF = EvaluateMaterialInteraction(Material, RayType);
    vec3 ThroughputForThisBounce = BxDF * ShadingData.NDotI / ShadingData.MaterialScatteringPDF;

    vec3 ThroughputBeforeThisBounce = CumulativeMaterialColorBuffer[PixelIndex].xyz;
    CumulativeMaterialColorBuffer[PixelIndex] = vec4(ThroughputBeforeThisBounce * ThroughputForThisBounce, 1);

    RayData.Direction.xyz = ShadingData.WorldSpaceOutgoingDirection;
    RayData.Origin.xyz = ShadingData.IntersectionCoordinatesInWorldSpace;
    RayData.RayFlags = (RayType & 0x0000FFFE) | (RayData.RayFlags & ~0x0000FFFE);

    /// Sample point light
    vec3 PointLightResult = vec3(0);
    vec3 DirectionalLightResult = vec3(0);
    vec3 SpotLightResult = vec3(0);
    vec3 AreaLightResult = vec3(0);
    vec3 IBLResult = vec3(0);
    vec3 TotalIncomingLight = vec3(0);
    SamplingState = FSamplingState(RenderIteration, PushConstants.BounceIndex, 0, PixelIndex, SAMPLE_TYPE_LIGHT);

    if (UtilityData.ActivePointLightsCount != 0 && !ShadingData.IsScatteredRaySingular)
    {
        vec4 UniformPointLightSamplingResult = vec4(0);
        vec4 ImportancePointLightSamplingResult = vec4(0);
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        float UniformSamplingImportanceSamplePDF = 0;
        float ImportanceSamplingUniformSamplePDF = 0;

        UniformPointLightSamplingResult = ComputeUniformPointLightInput(SamplingState, UtilityData.ActivePointLightsCount, UniformOutgoingDirection, UniformSamplingImportanceSamplePDF);
        ImportancePointLightSamplingResult = ComputeImportancePointLightInput(SamplingState, UtilityData.ActivePointLightsCount, ImportanceOutgoingDirection, ImportanceSamplingUniformSamplePDF);

        vec3 MaterialInteractionEvaluationResultUniformSampling = vec3(0); /// Interaction result of uniformly sampled point light and the surface
        vec3 MaterialInteractionEvaluationResultImportanceSampling = vec3(0); /// Interaction result of importance sampled point light and the surface

        float W1 = 0;
        float W2 = 0;

        if (UniformPointLightSamplingResult.w > 0.)
        {
            MaterialInteractionEvaluationResultUniformSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResultUniformSampling = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResultUniformSampling * UniformPointLightSamplingResult.xyz;
            W1 = UniformPointLightSamplingResult.w / (UniformPointLightSamplingResult.x + UniformSamplingImportanceSamplePDF);
        }

        if (ImportancePointLightSamplingResult.w > 0.)
        {
            MaterialInteractionEvaluationResultImportanceSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResultImportanceSampling = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResultImportanceSampling * ImportancePointLightSamplingResult.xyz;
            W2 = ImportancePointLightSamplingResult.w / (ImportancePointLightSamplingResult.w + ImportanceSamplingUniformSamplePDF);
        }

        PointLightResult = W1 * MaterialInteractionEvaluationResultUniformSampling + W2 * MaterialInteractionEvaluationResultImportanceSampling;
        TotalIncomingLight += UniformPointLightSamplingResult.xyz + ImportancePointLightSamplingResult.xyz;
    }

    /// Sample Directional light
    if (UtilityData.ActiveDirectionalLightsCount != 0 && !ShadingData.IsScatteredRaySingular)
    {
        vec4 UniformDirectionalLightSamplingResult = vec4(0);
        vec4 ImportanceDirectionalLightSamplingResult = vec4(0);
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        float UniformSamplingImportanceSamplePDF = 0;
        float ImportanceSamplingUniformSamplePDF = 0;

        UniformDirectionalLightSamplingResult = ComputeUniformDirectionalLightInput(SamplingState, UtilityData.ActiveDirectionalLightsCount, UniformOutgoingDirection, UniformSamplingImportanceSamplePDF);
        ImportanceDirectionalLightSamplingResult = ComputeImportanceDirectionalLightInput(SamplingState, UtilityData.ActiveDirectionalLightsCount, ImportanceOutgoingDirection, ImportanceSamplingUniformSamplePDF);

        vec3 MaterialInteractionEvaluationResultUniformSampling = vec3(0); /// Interaction result of uniformly sampled directional light and the surface
        vec3 MaterialInteractionEvaluationResultImportanceSampling = vec3(0); /// Interaction result of importance sampled directional light and the surface

        float W1 = 0;
        float W2 = 0;

        if (UniformDirectionalLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultUniformSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResultUniformSampling = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResultUniformSampling * UniformDirectionalLightSamplingResult.xyz;
            W1 = UniformDirectionalLightSamplingResult.w / (UniformDirectionalLightSamplingResult.x + UniformSamplingImportanceSamplePDF);
        }

        if (ImportanceDirectionalLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultImportanceSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResultImportanceSampling = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResultImportanceSampling * ImportanceDirectionalLightSamplingResult.xyz;
            W2 = ImportanceDirectionalLightSamplingResult.w / (ImportanceDirectionalLightSamplingResult.w + ImportanceSamplingUniformSamplePDF);
        }

        DirectionalLightResult = W1 * MaterialInteractionEvaluationResultUniformSampling + W2 * MaterialInteractionEvaluationResultImportanceSampling;
        TotalIncomingLight += UniformDirectionalLightSamplingResult.xyz + ImportanceDirectionalLightSamplingResult.xyz;
    }

    if(UtilityData.ActiveSpotLightsCount != 0 && !ShadingData.IsScatteredRaySingular)
    {
        vec4 UniformSpotLightSamplingResult = vec4(0);
        vec4 ImportanceSpotLightSamplingResult = vec4(0);
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        float UniformSamplingImportanceSamplePDF = 0;
        float ImportanceSamplingUniformSamplePDF = 0;

        UniformSpotLightSamplingResult = ComputeUniformSpotLightInput(SamplingState, UtilityData.ActiveSpotLightsCount, UniformOutgoingDirection, UniformSamplingImportanceSamplePDF);
        ImportanceSpotLightSamplingResult = ComputeImportanceSpotLightInput(SamplingState, UtilityData.ActiveSpotLightsCount, ImportanceOutgoingDirection, ImportanceSamplingUniformSamplePDF);

        vec3 MaterialInteractionEvaluationResultUniformSampling = vec3(0); /// Interaction result of uniformly sampled directional light and the surface
        vec3 MaterialInteractionEvaluationResultImportanceSampling = vec3(0); /// Interaction result of importance sampled directional light and the surface

        float W1 = 0;
        float W2 = 0;

        if (UniformSpotLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultUniformSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResultUniformSampling = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResultUniformSampling * UniformSpotLightSamplingResult.xyz;
            W1 = UniformSpotLightSamplingResult.w / (UniformSpotLightSamplingResult.x + UniformSamplingImportanceSamplePDF);
        }

        if (ImportanceSpotLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResultImportanceSampling = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResultImportanceSampling = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResultImportanceSampling * ImportanceSpotLightSamplingResult.xyz;
            W2 = ImportanceSpotLightSamplingResult.w / (ImportanceSpotLightSamplingResult.w + ImportanceSamplingUniformSamplePDF);
        }

        SpotLightResult = W1 * MaterialInteractionEvaluationResultUniformSampling + W2 * MaterialInteractionEvaluationResultImportanceSampling;
        TotalIncomingLight += UniformSpotLightSamplingResult.xyz + ImportanceSpotLightSamplingResult.xyz;
    }

    bool bBRDFAreaLightSamplingSuccessful = false;

    if (UtilityData.ActiveAreaLightsCount != 0)
    {
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        vec3 BXDFOutgoingDirection = ShadingData.WorldSpaceOutgoingDirection; ///We already have bxdf direction
        float UniformSamplingImportancePDF = 0.f;
        float UniformSamplingBXDFPDF = 0.f;
        float ImportanceSamplingUniformPDF = 0.f;
        float ImportanceSamplingBXDFPDF = 0.f;
        float BXDFSamplingUniformPDF = 0.f;
        float BXDFSamplingImportancePDF = 0.f;
        float W1 = 0.f;
        float W2 = 0.f;
        float W3 = 0.f;

        vec4 UniformAreaLightSamplingResult = ComputeUniformAreaLightInput(SamplingState, UniformOutgoingDirection, UniformSamplingImportancePDF, UniformSamplingBXDFPDF);
        vec4 ImportanceAreaLightSamplingResult = ComputeImportanceAreaLightInput(SamplingState, ImportanceOutgoingDirection, ImportanceSamplingUniformPDF, ImportanceSamplingBXDFPDF);
        vec4 BXDFAreaLightSamplingResult = ComputeBXDFAreaLightInput(SamplingState, BXDFOutgoingDirection, ShadingData.MaterialScatteringPDF, BXDFSamplingUniformPDF, BXDFSamplingImportancePDF);

        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of uniform sampled area light and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of importance sampled area light and the surface
        vec3 MaterialInteractionEvaluationResult3 = vec3(0); /// Interaction result of bxdf sampled area light and the surface

        if (UniformAreaLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResult1 = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResult1 * UniformAreaLightSamplingResult.xyz;
            W1 = UniformAreaLightSamplingResult.w / (UniformAreaLightSamplingResult.w + UniformSamplingImportancePDF + UniformSamplingBXDFPDF);
        }

        if (ImportanceAreaLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResult2 = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResult2 * ImportanceAreaLightSamplingResult.xyz;
            W2 = ImportanceAreaLightSamplingResult.w / (ImportanceAreaLightSamplingResult.w + ImportanceSamplingUniformPDF + ImportanceSamplingBXDFPDF);
        }

        if (BXDFAreaLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult3 = EvaluateMaterialInteractionFromDirection(Material, RayType, BXDFOutgoingDirection);
            MaterialInteractionEvaluationResult3 = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResult3 * BXDFAreaLightSamplingResult.xyz;
            W3 = BXDFAreaLightSamplingResult.w / (BXDFAreaLightSamplingResult.w + BXDFSamplingUniformPDF + BXDFSamplingImportancePDF);
            bBRDFAreaLightSamplingSuccessful = true;
        }

        AreaLightResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2 + W3 * MaterialInteractionEvaluationResult3;
        TotalIncomingLight += UniformAreaLightSamplingResult.xyz + ImportanceAreaLightSamplingResult.xyz + BXDFAreaLightSamplingResult.xyz;
    }

    if (true /*UtilityData.IBLIsActive*/)
    {
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        vec3 BXDFOutgoingDirection = ShadingData.WorldSpaceOutgoingDirection; ///We already have bxdf direction
        float UniformSamplingImportancePDF = 0.f;
        float UniformSamplingBXDFPDF = 0.f;
        float ImportanceSamplingUniformPDF = 0.f;
        float ImportanceSamplingBXDFPDF = 0.f;
        float BXDFSamplingUniformPDF = 0.f;
        float BXDFSamplingImportancePDF = 0.f;
        float W1 = 0.f;
        float W2 = 0.f;
        float W3 = 0.f;

        vec4 UniformIBLSamplingResult = ShadingData.IsScatteredRaySingular ? vec4(0) : ComputeUniformIBLInput(SamplingState, UniformOutgoingDirection, UniformSamplingImportancePDF, UniformSamplingBXDFPDF);
        vec4 ImportanceIBLSamplingResult = ShadingData.IsScatteredRaySingular ? vec4(0) : ComputeImportanceIBLInput(SamplingState, ImportanceOutgoingDirection, ImportanceSamplingUniformPDF, ImportanceSamplingBXDFPDF);
        vec4 BXDFIBLSamplingResult = ComputeBXDFIBLInput(SamplingState, BXDFOutgoingDirection, ShadingData.MaterialScatteringPDF, BXDFSamplingUniformPDF, BXDFSamplingImportancePDF);

        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of uniform sampled IBL and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of importance sampled IBL and the surface
        vec3 MaterialInteractionEvaluationResult3 = vec3(0); /// Interaction result of bxdf sampled IBL and the surface

        if (UniformIBLSamplingResult.w != 0 && !ShadingData.IsScatteredRaySingular)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteractionFromDirection(Material, RayType, UniformOutgoingDirection);
            MaterialInteractionEvaluationResult1 = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResult1 * UniformIBLSamplingResult.xyz;
            W1 = UniformIBLSamplingResult.w / (UniformIBLSamplingResult.w + UniformSamplingImportancePDF + UniformSamplingBXDFPDF);
        }

        if (ImportanceIBLSamplingResult.w != 0 && !ShadingData.IsScatteredRaySingular)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteractionFromDirection(Material, RayType, ImportanceOutgoingDirection);
            MaterialInteractionEvaluationResult2 = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResult2 * ImportanceIBLSamplingResult.xyz;
            W2 = ImportanceIBLSamplingResult.w / (ImportanceIBLSamplingResult.w + ImportanceSamplingUniformPDF + ImportanceSamplingBXDFPDF);
        }

        if (BXDFIBLSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult3 = EvaluateMaterialInteractionFromDirection(Material, RayType, BXDFOutgoingDirection);
            MaterialInteractionEvaluationResult3 = ThroughputBeforeThisBounce * MaterialInteractionEvaluationResult3 * BXDFIBLSamplingResult.xyz;
            W3 = BXDFIBLSamplingResult.w / (BXDFIBLSamplingResult.w + BXDFSamplingUniformPDF + BXDFSamplingImportancePDF);
        }

        IBLResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2 + W3 * MaterialInteractionEvaluationResult3;
        TotalIncomingLight += UniformIBLSamplingResult.xyz + ImportanceIBLSamplingResult.xyz + BXDFIBLSamplingResult.xyz;
    }

    vec3 BounceInput = vec3(0);
    BounceInput += PointLightResult + DirectionalLightResult + SpotLightResult + AreaLightResult + IBLResult;
    ThroughputBuffer[PixelIndex].xyz = ThroughputBuffer[PixelIndex].xyz + BounceInput;

    if ((PushConstants.BounceIndex == LAST_DIFFUSE_BOUNCE && CheckFlag(RayData.RayFlags, DIFFUSE_LAYER))
    || (PushConstants.BounceIndex == LAST_REFLECTION_BOUNCE && CheckFlag(RayData.RayFlags, SPECULAR_LAYER))
    || (PushConstants.BounceIndex == LAST_REFRACTION_BOUNCE && CheckFlag(RayData.RayFlags, TRANSMISSION_LAYER))
    || (ShadingData.MaterialScatteringPDF <= 0.0001f)
    || bBRDFAreaLightSamplingSuccessful) /// If we know that scattered ray hit some area light, no need to precess him
    {
        RayDataBuffer[PixelIndex].RayFlags = RAY_DATA_RAY_MISSED;
        imageStore(OutcomingImage, ivec2(PixelCoords), vec4(ThroughputBuffer[PixelIndex].xyz , 1));
        return;
    }

    if (PushConstants.BounceIndex == LAST_BOUNCE)
    {
        imageStore(OutcomingImage, ivec2(PixelCoords), vec4(ThroughputBuffer[PixelIndex].xyz , 1));
        return;
    }

    RayDataBuffer[PixelIndex] = RayData;
    NormalBuffer[PixelIndex] = vec4(ShadingData.NormalInWorldSpace, 1);

    if(PushConstants.BounceIndex == 0)
    {
        SaveAOVs(PixelCoords, ShadingData.NormalInWorldSpace, ShadingData.NormalInWorldSpace, ShadingData.UVCoordinates, ShadingData.IntersectionCoordinatesInWorldSpace, 1., Depth,
        Material.BaseColor, TotalIncomingLight, Hit.RenderableIndex, Hit.PrimitiveIndex, PushConstants.MaterialIndex,
        DebugGlobal0, DebugGlobal1, DebugGlobal2, DebugGlobal3);
    }
}
