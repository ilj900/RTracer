#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : enable // ?

//#define DEBUG_PRINTF
#ifdef DEBUG_PRINTF
#extension GL_EXT_debug_printf : enable
bool b = false;
#endif

vec4 DebugGlobal = vec4(0);

#include "common_defines.h"
#include "common_structures.h"
#include "random.h"
#include "glsl_math.h"
#include "bxdf.h"
#include "process_material_interaction.h"

layout (location = 0) rayPayloadEXT FHitPayload HitPayload;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TLAS_INDEX) uniform accelerationStructureEXT TLAS;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TEXTURE_SAMPLER) uniform sampler Sampler;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TEXTURE_ARRAY) uniform texture2D Textures[MAX_TEXTURES];

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RAYS_BUFFER_INDEX) buffer RaysBufferObject
{
    FRayData RayDataBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_HITS_BUFFER_INDEX) buffer HitsBufferObject
{
    FHit Hits[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDERABLES_BUFFER_INDEX) buffer RenderablesBufferObject
{
    FRenderable Renderables[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_TRANSFORMS_BUFFER_INDEX) buffer TransformsBufferObject
{
    FDeviceTransform DeviceTransforms[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_MATERIALS_OFFSETS) buffer MaterialsOffsetsBufferObject
{
    uint MaterialsOffsets[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_PIXEL_INDEX_BUFFER) buffer PixelIndexIndexMapBufferObject
{
    uint PixelIndexIndexMap[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DIRECTIONAL_LIGHTS_BUFFER_INDEX) buffer DirectionalLightsBufferObject
{
    FDirectionalLight DirectionalLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DIRECTIONAL_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer DirectionalLightsImportanceBufferObject
{
    FDeviceAliasTableEntry DirectionalLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SPOT_LIGHTS_BUFFER_INDEX) buffer SpotLightsBufferObject
{
    FSpotLight SpotLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SPOT_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer SpotLightsImportanceBufferObject
{
    FDeviceAliasTableEntry SpotLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_POINT_LIGHTS_BUFFER_INDEX) buffer PointLightsBufferObject
{
    FPointLight PointLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_POINT_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer PointLightsImportanceBufferObject
{
    FDeviceAliasTableEntry PointLightsImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_AREA_LIGHTS_BUFFER_INDEX) buffer AreaLightsBufferObject
{
    FAreaLight AreaLightsBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_AREA_LIGHTS_IMPORTANCE_BUFFER_INDEX) buffer AreaLightsImportanceBufferObject
{
    FDeviceAliasTableEntry AreaLightsImportanceBuffer[];
};

layout (buffer_reference, scalar) buffer AreaLightsAliasTableReference
{
    FDeviceAliasTableEntry AreaLightsAliasTable[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_IMPORTANCE_BUFFER_INDEX) buffer IBLImportanceBufferObject
{
    FDeviceAliasTableEntry IBLImportanceBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_IMAGE_SAMPLER_INDEX) uniform sampler2D IBLTextureSampler;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_IBL_PDF_BUFFER_INDEX) buffer IBLPDFBufferObject
{
    float IBLPDFBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_UTILITY_BUFFER_INDEX) uniform UtilityDataUniformBufferObject
{
    FUtilityData UtilityData;
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDER_ITERATION_BUFFER_INDEX) buffer RenderIterationBufferObject
{
    uint RenderIteration;
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_CUMULATIVE_MATERIAL_COLOR_BUFFER_INDEX) buffer CumulativeMaterialColorBufferObject
{
    vec4 CumulativeMaterialColorBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_NORMAL_BUFFER) buffer NormalBufferObject
{
    vec4 NormalBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_THROUGHPUT_BUFFER) buffer ThroughputBufferObject
{
    vec4 ThroughputBuffer[];
};

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_COLOR_AOV_IMAGE_INDEX, rgba32f) uniform image2D OutcomingImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_SHADING_NORMAL_AOV_IMAGE_INDEX, rgba32f) uniform image2D ShadingNormalAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_GEOMETRIC_NORMAL_AOV_IMAGE_INDEX, rgba32f) uniform image2D GeometricNormalAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_UV_AOV_IMAGE_INDEX, rg32f) uniform image2D UVAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_WORLD_SPACE_POSITION_AOV_IMAGE_INDEX, rgba32f) uniform image2D WorldSpacePositionAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_OPACITY_AOV_IMAGE_INDEX, rgba32f) uniform image2D OpacityAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEPTH_AOV_IMAGE_INDEX, rgba32f) uniform image2D DepthAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_ALBEDO_AOV_IMAGE_INDEX, rgba32f) uniform image2D AlbedoAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_LUMINANCE_AOV_IMAGE_INDEX, rgba32f) uniform image2D LuminanceAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_RENDERABLE_INDEX_IMAGE_INDEX, rgba32f) uniform image2D RenderableIndexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_PRIMITIVE_INDEX_IMAGE_INDEX, rgba32f) uniform image2D PrimitiveIndexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_MATERIAL_INDEX_IMAGE_INDEX, rgba32f) uniform image2D MaterialindexAOVImage;

layout (set = MASTER_SHADER_LAYOUT_INDEX, binding = MASTER_SHADER_DEBUG_LAYER_IMAGE_INDEX, rgba32f) uniform image2D DebugLayerImage;

layout (buffer_reference, scalar) buffer Vertices
{
    FDeviceVertex V[];
};

layout (buffer_reference, scalar) buffer Indices
{
    int I[];
};

layout (push_constant) uniform PushConstantsBlock
{
    FPushConstants PushConstants;
};

bool CheckFlag(uint Mask, uint Field)
{
    return (Mask & Field) == Field;
}

bool IsIndexed(FRenderable Renderable)
{
    return CheckFlag(Renderable.RenderablePropertyMask, RENDERABLE_IS_INDEXED);
}

FVertex UnpackDeviceVertex(FDeviceVertex DV)
{
    FVertex V;
    V.Position.x = DV.A.x;
    V.Position.y = DV.A.y;
    V.Position.z = DV.A.z;
    V.Normal.x = DV.A.w;
    V.Normal.y = DV.B.x;
    V.Normal.z = DV.B.y;
    V.TexCoord.x = DV.B.z;
    V.TexCoord.y = DV.B.w;
    return V;
}

vec3 SampleVec3(uint TextureIndex, vec2 TextureCoords)
{
    return texture(sampler2D(Textures[TextureIndex], Sampler), TextureCoords).rgb;
}

float SampleFloat(uint TextureIndex, vec2 TextureCoords)
{
    return texture(sampler2D(Textures[TextureIndex], Sampler), TextureCoords).r;
}

FDeviceMaterial GetMaterial(vec2 TextureCoords);

FDeviceMaterial GetEmissiveMaterial(vec2 TextureCoords, uint MaterialIndex);

void ComputeShadingData(FRenderable Renderable, FHit Hit, FDeviceTransform Transform,
out vec3 NormalInWorldSpace, out vec3 PointOfIntersectionInWorldSpace, out vec2 TextureCoords)
{
    Vertices Verts = Vertices(Renderable.VertexBufferAddress);
    Indices Inds = Indices(Renderable.IndexBufferAddress);
    vec3 Barycentrics = vec3(1.0 - Hit.HitUV.x - Hit.HitUV.y, Hit.HitUV.x, Hit.HitUV.y);

    FDeviceVertex DV0;
    FDeviceVertex DV1;
    FDeviceVertex DV2;

    if (IsIndexed(Renderable))
    {
        uint I0 = 0;
        uint I1 = 1;
        uint I2 = 2;

        I0 = Inds.I[Hit.PrimitiveIndex * 3];
        I1 = Inds.I[Hit.PrimitiveIndex * 3 + 1];
        I2 = Inds.I[Hit.PrimitiveIndex * 3 + 2];

        DV0 = Verts.V[I0];
        DV1 = Verts.V[I1];
        DV2 = Verts.V[I2];
    }
    else
    {
        uint Index = Hit.PrimitiveIndex * 3;
        DV0 = Verts.V[Index];
        DV1 = Verts.V[Index + 1];
        DV2 = Verts.V[Index + 2];
    }

    FVertex V0 = UnpackDeviceVertex(DV0);
    FVertex V1 = UnpackDeviceVertex(DV1);
    FVertex V2 = UnpackDeviceVertex(DV2);

    NormalInWorldSpace = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
    /// Pay more attention to why vector * matrix, and not vice versa
    NormalInWorldSpace = NormalInWorldSpace * mat3(Transform.InverseModelMatrix);
    NormalInWorldSpace = normalize(NormalInWorldSpace);

    PointOfIntersectionInWorldSpace = V0.Position * Barycentrics.x + V1.Position * Barycentrics.y + V2.Position * Barycentrics.z;
    PointOfIntersectionInWorldSpace = vec3(vec4(PointOfIntersectionInWorldSpace, 1.f) * Transform.ModelMatrix);

    /// TODO: Can Hit.HitUV just be used?
    TextureCoords = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;
}

vec4 ComputeUniformDirectionalLightInput(inout FSamplingState SamplingState, uint DirectionalLightsCount, vec3 Normal, vec3 WorldSpacePosition, out vec3 Direction)
{
    /// Get light index by uniformly sampling it
    const uint UniformLightIndex = uint(RandomFloat(SamplingState) * DirectionalLightsCount);
    FDirectionalLight DirectionalLightUniform = DirectionalLightsBuffer[UniformLightIndex];

    /// Check whether light is over the surface
    Direction = -DirectionalLightUniform.Direction;
    float NDotI = dot(Normal, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        /// Here, the probability of sampling a particular directional light is one to the number of directional lights
        /// We multiply by the number of lights cause it's inverse of the PDF
        return vec4(DirectionalLightUniform.Color * DirectionalLightUniform.Intensity * NDotI * DirectionalLightsCount, 1.f / DirectionalLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

/// Sample a directional light by it's power
vec4 ComputeImportanceDirectionalLightInput(inout FSamplingState SamplingState, uint DirectionalLightsCount, vec3 Normal, vec3 WorldSpacePosition, out vec3 Direction)
{
    /// Get light index by importance sampling it
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * DirectionalLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = DirectionalLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FDirectionalLight DirectionalLightImportance = DirectionalLightsBuffer[ImportanceLightIndex];

    Direction = -DirectionalLightImportance.Direction;

    /// Check whether light is over the surface
    float NDotI = dot(Normal, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        /// Here, the probability of sampling a particular directional light is it's power to the total power of all directional light
        float PDF = DirectionalLightImportance.Power / UtilityData.TotalDirectionalLightPower;
        return vec4(DirectionalLightImportance.Color * DirectionalLightImportance.Intensity * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformPointLightInput(inout FSamplingState SamplingState, uint PointLightsCount, vec3 Normal, vec3 WorldSpacePosition, out vec3 Direction)
{
    /// Get light index
    const uint LightIndex = uint(RandomFloat(SamplingState) * PointLightsCount);
    FPointLight PointLightUniform = PointLightsBuffer[LightIndex];
    Direction = PointLightUniform.Position - WorldSpacePosition;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(Normal, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;
        /// Here, the probability of sampling a particular point light is one to the number of point lights
        return vec4(PointLightUniform.Color * PointLightUniform.Intensity * Attenuation * NDotI * PointLightsCount, 1.f / PointLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportancePointLightInput(inout FSamplingState SamplingState, uint PointLightsCount, vec3 Normal, vec3 WorldSpacePosition, out vec3 Direction)
{
    /// Get light index by importance sampling it
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * PointLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = PointLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FPointLight PointLightImportance = PointLightsBuffer[ImportanceLightIndex];

    Direction = PointLightImportance.Position - WorldSpacePosition;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(Normal, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, LightDistance, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;
        /// Here, the probability of sampling a particular point light depends on it's power and total power of all lights
        float PDF = PointLightImportance.Power / UtilityData.TotalPointLightPower;
        return vec4(PointLightImportance.Color * PointLightImportance.Intensity * Attenuation * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeUniformSpotLightInput(inout FSamplingState SamplingState, uint SpotLightsCount, vec3 Normal, vec3 WorldSpacePosition, out vec3 Direction)
{
    /// Get light index
    const uint LightIndex = uint(RandomFloat(SamplingState) * SpotLightsCount);
    FSpotLight SpotLight = SpotLightsBuffer[LightIndex];
    Direction = SpotLight.Position - WorldSpacePosition;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(Normal, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    float LightAngle = acos(dot(SpotLight.Direction, -Direction));
    /// If point is outside out outer angle, it is also not illuminated
    if (LightAngle > SpotLight.OuterAngle)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;

        /// If point between outer and inner angle - interpolate
        if (LightAngle > SpotLight.InnerAngle)
        {
            float Fraction = LightAngle - SpotLight.InnerAngle;
            float Delta = SpotLight.OuterAngle - SpotLight.InnerAngle;
            Fraction = Fraction / Delta;
            Attenuation *= pow((1. - Fraction), 2.4);
        }

        /// Here, the probability of sampling a particular spot light is one to the number of spot lights
        return vec4(SpotLight.Color * SpotLight.Intensity * Attenuation * NDotI * SpotLightsCount, 1.f / SpotLightsCount);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportanceSpotLightInput(inout FSamplingState SamplingState, uint SpotLightsCount, vec3 Normal, vec3 WorldSpacePosition, out vec3 Direction)
{
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * SpotLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = SpotLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FSpotLight SpotLightImportance = SpotLightsBuffer[ImportanceLightIndex];

    Direction = SpotLightImportance.Position - WorldSpacePosition;
    float LightDistance = length(Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    float NDotI = dot(Normal, Direction);

    if(NDotI <= 0)
    {
        return vec4(0);
    }

    float LightAngle = acos(dot(SpotLightImportance.Direction, -Direction));
    /// If point is outside out outer angle, it is also not illuminated
    if (LightAngle > SpotLightImportance.OuterAngle)
    {
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we store light data
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Attenuation = 1.f / LightDistance;
        Attenuation *= Attenuation;

        /// If point between outer and inner angle - interpolate
        if (LightAngle > SpotLightImportance.InnerAngle)
        {
            float Fraction = LightAngle - SpotLightImportance.InnerAngle;
            float Delta = SpotLightImportance.OuterAngle - SpotLightImportance.InnerAngle;
            Fraction = Fraction / Delta;
            Attenuation *= pow((1. - Fraction), 2.4);
        }

        /// Here, the probability of sampling a particular spot light is dependent on the spot light's power and total spot lights power
        float PDF = SpotLightImportance.Power / UtilityData.TotalSpotLightPower;
        return vec4(SpotLightImportance.Color * SpotLightImportance.Intensity * Attenuation * NDotI / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportanceAreaLightInput(inout FSamplingState SamplingState, uint AreaLightsCount, vec3 Normal, vec3 WorldSpacePosition, out float NDotL,  out vec3 Direction)
{
    /// First - select and area light based on it's area
    uint ImportanceLightIndex = uint(RandomFloat(SamplingState) * AreaLightsCount);
    FDeviceAliasTableEntry ImportanceSampleTableEntry = AreaLightsImportanceBuffer[ImportanceLightIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceLightIndex = ImportanceSampleTableEntry.Alias;
    }

    FAreaLight ArealLightImportance = AreaLightsBuffer[ImportanceLightIndex];

    /// Second - select a triangle within area light based on it's area
    uint ImportanceTriangleIndex = uint(RandomFloat(SamplingState) * ArealLightImportance.NumberOfTriangles);
    AreaLightsAliasTableReference AreaLightAliasTable = AreaLightsAliasTableReference(ArealLightImportance.AliasTableBufferAddress);

    ImportanceSampleTableEntry = AreaLightAliasTable[ImportanceTriangleIndex];

    if (RandomFloat(SamplingState) > ImportanceSampleTableEntry.Threshold)
    {
        ImportanceTriangleIndex = ImportanceSampleTableEntry.Alias;
    }

    /// Get random triangle from the mesh that is marked as area light
    Vertices Verts = Vertices(ArealLightImportance.VertexBufferAddress);
    Indices Inds = Indices(ArealLightImportance.IndexBufferAddress);
    bool RenderableIsIndexed = (ArealLightImportance.IsIndexedFlagAndRenderableIndex & 0x80000000) == 0x80000000;
    uint RenderableIndex = ArealLightImportance.IsIndexedFlagAndRenderableIndex & 0x7FFFFFFF;

    FDeviceVertex DV0;
    FDeviceVertex DV1;
    FDeviceVertex DV2;

    if (RenderableIsIndexed)
    {
        uint I0 = 0;
        uint I1 = 1;
        uint I2 = 2;

        I0 = Inds.I[ImportanceTriangleIndex * 3];
        I1 = Inds.I[ImportanceTriangleIndex * 3 + 1];
        I2 = Inds.I[ImportanceTriangleIndex * 3 + 2];

        DV0 = Verts.V[I0];
        DV1 = Verts.V[I1];
        DV2 = Verts.V[I2];
    }
    else
    {
        uint Index = ImportanceTriangleIndex * 3;
        DV0 = Verts.V[Index];
        DV1 = Verts.V[Index + 1];
        DV2 = Verts.V[Index + 2];
    }

    /// Unpack data
    FVertex V0 = UnpackDeviceVertex(DV0);
    FVertex V1 = UnpackDeviceVertex(DV1);
    FVertex V2 = UnpackDeviceVertex(DV2);

    /// Sample random point on that triangle
    vec2 RandomVec2 = Sample2DUnitQuad(SamplingState);

    /// Without this, RandomPoint will be placed in parallelogram denoted by the triangle
    if (RandomVec2.x + RandomVec2.y > 1.)
    {
        RandomVec2.x = 1. - RandomVec2.x;
        RandomVec2.y = 1. - RandomVec2.y;
    }

    /// Here, RandomPoint is in local space
    vec3 RandomPoint = V0.Position + (V1.Position - V0.Position) * RandomVec2.x + (V2.Position - V0.Position) * RandomVec2.y;

    /// Transform point into world-space
    FDeviceTransform Transform = DeviceTransforms[ArealLightImportance.TransformIndex];
    RandomPoint = vec3(vec4(RandomPoint, 1.f) * Transform.ModelMatrix);
    /// A direction to light
    Direction = RandomPoint - WorldSpacePosition;
    float Distance2 = dot(Direction, Direction);
    Direction = normalize(Direction);

    /// Check whether light is over the surface
    NDotL = dot(Normal, Direction);

    if(NDotL <= 0)
    {
        /// Light is on the other side
        return vec4(0);
    }

    /// Construct a ray that goes to the light
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Direction;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// And if we did hit a required triange, then we store light data
    if (HitPayload.PrimitiveIndex == ImportanceTriangleIndex && HitPayload.RenderableIndex == RenderableIndex)
    {
        vec3 Barycentrics = vec3(1.f - HitPayload.HitUV.x - HitPayload.HitUV.y, HitPayload.HitUV.x, HitPayload.HitUV.y);

        /// Compute UV
        vec2 UV = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;
        /// Compute normal
        vec3 AreaLightTriangleNormal = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
        AreaLightTriangleNormal = AreaLightTriangleNormal * mat3(Transform.InverseModelMatrix);
        AreaLightTriangleNormal = normalize(AreaLightTriangleNormal);
        float NDotI = abs(dot(AreaLightTriangleNormal, Direction));

        /// Get the material
        FDeviceMaterial EmissiveMaterial = GetEmissiveMaterial(UV, ArealLightImportance.MaterialIndex);
        /// TODO: Is this a correct PDF formula?
        float PDF = Distance2;
        PDF /= UtilityData.TotalAreaLightArea;
        PDF /= NDotI;
        /// TODO: divide by emission weight?

        return vec4(EmissiveMaterial.EmissionColor / PDF, PDF);
    }
    else
    {
        /// Something ocludded the light
        return vec4(0);
    }
}

vec4 ComputeBXDFAreaLightInput(inout FSamplingState SamplingState, vec3 Normal, vec3 WorldSpacePosition, vec3 Outgoing, float BxDFPDF)
{
    /// Construct a shadow ray
    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = Outgoing;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, 0.000001f, RayData.Direction.xyz, 10000, 0);

    /// If we hit any geometry, let's check whether it's an emissive
    if (HitPayload.RenderableIndex != UINT_MAX)
    {
        FRenderable Renderable = Renderables[HitPayload.RenderableIndex];
        Vertices Verts = Vertices(Renderable.VertexBufferAddress);
        Indices Inds = Indices(Renderable.IndexBufferAddress);

        FDeviceVertex DV0;
        FDeviceVertex DV1;
        FDeviceVertex DV2;

        if (IsIndexed(Renderable))
        {
            uint I0 = 0;
            uint I1 = 1;
            uint I2 = 2;

            I0 = Inds.I[HitPayload.PrimitiveIndex * 3];
            I1 = Inds.I[HitPayload.PrimitiveIndex * 3 + 1];
            I2 = Inds.I[HitPayload.PrimitiveIndex * 3 + 2];

            DV0 = Verts.V[I0];
            DV1 = Verts.V[I1];
            DV2 = Verts.V[I2];
        }
        else
        {
            uint Index = HitPayload.PrimitiveIndex * 3;
            DV0 = Verts.V[Index];
            DV1 = Verts.V[Index + 1];
            DV2 = Verts.V[Index + 2];
        }

        /// Unpack data
        FVertex V0 = UnpackDeviceVertex(DV0);
        FVertex V1 = UnpackDeviceVertex(DV1);
        FVertex V2 = UnpackDeviceVertex(DV2);

        vec3 Barycentrics = vec3(1.0 - HitPayload.HitUV.x - HitPayload.HitUV.y, HitPayload.HitUV.x, HitPayload.HitUV.y);
        vec2 TextureCoords = V0.TexCoord * Barycentrics.x + V1.TexCoord * Barycentrics.y + V2.TexCoord * Barycentrics.z;

        /// TODO: Optimize
        FDeviceMaterial EmissiveMaterial = GetEmissiveMaterial(TextureCoords, Renderable.MaterialIndex);

        if (EmissiveMaterial.EmissionWeight != 0)
        {
            FDeviceTransform Transform = DeviceTransforms[Renderable.TransformIndex];

            vec3 EmissiveNormalInWorldSpace = (V0.Normal * Barycentrics.x + V1.Normal * Barycentrics.y + V2.Normal * Barycentrics.z);
            /// Pay more attention to why vector * matrix, and not vice versa
            EmissiveNormalInWorldSpace = EmissiveNormalInWorldSpace * mat3(Transform.InverseModelMatrix);
            EmissiveNormalInWorldSpace = normalize(EmissiveNormalInWorldSpace);

            /// This is the cosine of the angle betweeen the emissive triangle's normal and a shaddow ray direction
            /// Why do we take the abs? Because the shadow ray is guaranted to be on the correct side of the hemisphere and
            /// we don't have two sided materials, so emissive emmit on both sides
            float NDotI = abs(dot(EmissiveNormalInWorldSpace, RayData.Direction.xyz));

            vec4 Result = vec4(0);
            Result.xyz = EmissiveMaterial.EmissionColor * NDotI * EmissiveMaterial.EmissionWeight;
            /// PDF is alreaddy known due to material evaluation
            Result.w = BxDFPDF;

            return Result;
        }
    }

    return vec4(0);
}

vec4 ComputeUniformIBLInput(inout FSamplingState SamplingState, out vec3 LightDirection, vec3 Normal, vec3 WorldSpacePosition)
{
    /// TODO: Verify that sampling is uniform
    /// Sample a random direction in the hemisphere and transform it into world-space cs
    const vec3 LocalspaceRandomDirection = Sample3DUnitHemisphere(SamplingState);
    LightDirection = Transform(Normal, LocalspaceRandomDirection);

    float NDotL = dot(Normal, LightDirection);

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float Phi = atan(RayData.Direction.z, RayData.Direction.x);
        Phi += M_PI_2;
        float Theta = acos(RayData.Direction.y);
        Phi /= M_2_PI;
        Theta /= M_PI;

        float PDF = 0.5f * M_INV_PI;
        return vec4(texture(IBLTextureSampler, vec2(Phi, Theta)).xyz * NDotL / PDF, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeImportanceIBLInput(inout FSamplingState SamplingState, out vec3 LightDirection, vec3 Normal, vec3 WorldSpacePosition)
{
    const vec2 SampleUV = Sample2DUnitQuad(SamplingState);
    const uvec2 IBLSize = textureSize(IBLTextureSampler, 0);
    uint TexelIndex = uint(IBLSize.x * IBLSize.y * SampleUV.y) + uint(IBLSize.x * SampleUV.x);

    FDeviceAliasTableEntry ImportanceSampleInterval = IBLImportanceBuffer[TexelIndex];
    /// Get texel index
    if (RandomFloat(SamplingState) > ImportanceSampleInterval.Threshold)
    {
        TexelIndex = ImportanceSampleInterval.Alias;
    }

    /// Transform texel index into actual UV coordinates
    vec2 UVCoordinates = vec2((float(TexelIndex % IBLSize.x) + 0.5) / float(IBLSize.x), (float(TexelIndex / IBLSize.x) + 0.5) / float(IBLSize.y));
    /// Map them to spherical coordinates
    vec2 SphericalCoordinates = UVCoordinates * vec2(M_2_PI, M_PI);
    SphericalCoordinates.x -= M_PI_2;
    LightDirection.x = sin(SphericalCoordinates.y) * cos(SphericalCoordinates.x);
    LightDirection.y = cos(SphericalCoordinates.y);
    LightDirection.z = sin(SphericalCoordinates.y) * sin(SphericalCoordinates.x);

    float NDotL = dot(Normal, LightDirection);

    if(NDotL <= 0)
    {
        return vec4(0);
    }

    FRayData RayData;
    RayData.RayFlags = 0;
    RayData.Direction.xyz = LightDirection;
    RayData.Origin.xyz = WorldSpacePosition + Normal * FLOAT_EPSILON;

    /// Trace the ray
    traceRayEXT(TLAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, RayData.Origin.xyz, FLOAT_EPSILON, RayData.Direction.xyz, 10000, 0);

    /// And if we didn't hit any geometry, then we sample the IBL
    if (HitPayload.RenderableIndex == UINT_MAX)
    {
        float PDF = IBLPDFBuffer[TexelIndex];
        return vec4(texture(IBLTextureSampler, UVCoordinates).xyz * NDotL, PDF);
    }
    else
    {
        return vec4(0);
    }
}

vec4 ComputeBXDFIBLInput(inout FSamplingState SamplingState, vec3 LightDirection, vec3 Normal, vec3 WorldSpacePosition)
{
    return vec4(1);
}

vec4 IndexToColor(uint Value)
{
    uint ColorHash = MurMur3_32(Value, 0);
    vec4 Color = vec4(0);
    Color.x = ((ColorHash >> 24) & 0xFFu) / 255.;
    Color.y = ((ColorHash >> 18) & 0xFFu) / 255.;
    Color.z = ((ColorHash >> 12) & 0xFFu) / 255.;
    return Color;
}

void SaveAOVs(uvec2 PixelCoords, vec3 ShadingNormal, vec3 GeometricNormal, vec2 UV, vec3 WorldSpacePosition, float Opacity, float Depth, vec3 Albedo,
              vec3 Luminance, uint RenderableIndex, uint PrimitiveIndex, uint Materialindex, vec4 DebugData)
{
    imageStore(ShadingNormalAOVImage, ivec2(PixelCoords), vec4((ShadingNormal + vec3(1)) * vec3(0.5), 0));
    imageStore(GeometricNormalAOVImage, ivec2(PixelCoords), vec4((GeometricNormal + vec3(1)) * vec3(0.5), 0));
    imageStore(UVAOVImage, ivec2(PixelCoords), vec4(UV, 0, 0));
    imageStore(WorldSpacePositionAOVImage, ivec2(PixelCoords), vec4(WorldSpacePosition, 0));
    imageStore(OpacityAOVImage, ivec2(PixelCoords), vec4(Opacity, Opacity, Opacity, 0));
    imageStore(DepthAOVImage, ivec2(PixelCoords), vec4(Depth, Depth, Depth, 0));
    imageStore(AlbedoAOVImage, ivec2(PixelCoords), vec4(Albedo, 0));
    imageStore(LuminanceAOVImage, ivec2(PixelCoords), vec4(Luminance, 0));

    vec4 RenderableIdColor = IndexToColor(RenderableIndex);
    imageStore(RenderableIndexAOVImage, ivec2(PixelCoords), RenderableIdColor);

    vec4 PrimitiveIdColor = IndexToColor(PrimitiveIndex);
    imageStore(PrimitiveIndexAOVImage, ivec2(PixelCoords), PrimitiveIdColor);

    vec4 MaterialIdColor = IndexToColor(Materialindex);
    imageStore(MaterialindexAOVImage, ivec2(PixelCoords), MaterialIdColor);

    imageStore(DebugLayerImage, ivec2(PixelCoords), DebugData);
}

void main()
{
    /// Find actual pixel we are working with
    uint OriginalPixelIndex = MaterialsOffsets[PushConstants.MaterialIndex] + gl_LaunchIDEXT.x;
    uint PixelIndex = PixelIndexIndexMap[OriginalPixelIndex];
    uvec2 PixelCoords = uvec2(PixelIndex % PushConstants.Width, PixelIndex / PushConstants.Width);

#ifdef DEBUG_PRINTF
    if (PixelCoords.x == PushConstants.Width / 2 && PixelCoords.y == PushConstants.Height / 2 && PushConstants.BounceIndex == 0)
    {
        b = true;
        //debugPrintfEXT("Bounse: %i\n", PushConstants.BounceIndex);
    }
#endif

    /// Fetch required data
    FRayData RayData = RayDataBuffer[PixelIndex];
    FHit Hit = Hits[PixelIndex];
    FRenderable Renderable = Renderables[Hit.RenderableIndex];
    FDeviceTransform Transform = DeviceTransforms[Renderable.TransformIndex];

    vec3 NormalInWorldSpace = vec3(1);
    vec3 WorldSpacePosition = vec3(1);
    vec2 TextureCoords = vec2(1);
    ComputeShadingData(Renderable, Hit, Transform, NormalInWorldSpace, WorldSpacePosition, TextureCoords);
    float NDotI = dot(NormalInWorldSpace.xyz, RayData.Direction.xyz);
    bool bFrontFacing = true;
    float Depth = length(WorldSpacePosition - RayData.Origin.xyz) * 0.0001f;

    if (NDotI > 0)
    {
        bFrontFacing = false;
        NormalInWorldSpace = -NormalInWorldSpace;
    }

    /// Fetch material data
    FDeviceMaterial Material = GetMaterial(TextureCoords);
    /// Process material interaction
    vec3 Incoming = RayData.Direction.xyz;
    FSamplingState SamplingState = FSamplingState(RenderIteration, PushConstants.BounceIndex, 0, PixelIndex, SAMPLE_TYPE_GENERATE_RAYS);
    float MaterialScatteringPDF = ScatterMaterial(Material, RayData, NormalInWorldSpace, SamplingState, bFrontFacing);

    /// Compute all possible lighting inputs
    vec4 UniformDirectionalLightSamplingResult = vec4(0);
    vec4 ImportanceDirectionalLightSamplingResult = vec4(0);
    vec3 DirectionalLightResult = vec3(0);
    vec4 UniformPointLightSamplingResult = vec4(0);
    vec4 ImportancePointLightSamplingResult = vec4(0);
    vec3 PointLightResult = vec3(0);
    vec4 UniformSpotLightSamplingResult = vec4(0);
    vec4 ImportanceSpotLightSamplingResult = vec4(0);
    vec3 SpotLightResult = vec3(0);
    vec4 ImportanceAreaLightSamplingResult = vec4(0);
    vec4 BXDFAreaLightSamplingResult = vec4(0);
    vec3 AreaLightResult = vec3(0);
    vec4 UniformIBLSamplingResult = vec4(0);
    vec4 ImportanceIBLSamplingResult = vec4(0);
    vec4 BXDFIBLSamplingResult = vec4(0);
    vec3 IBLResult = vec3(0);
    vec3 TotalIncomingLight = vec3(0);

    SamplingState = FSamplingState(RenderIteration, PushConstants.BounceIndex, 0, PixelIndex, SAMPLE_TYPE_LIGHT);

    /// MIS directional lights
    if (UtilityData.ActiveDirectionalLightsCount != 0)
    {
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        UniformDirectionalLightSamplingResult = ComputeUniformDirectionalLightInput(SamplingState, UtilityData.ActiveDirectionalLightsCount, NormalInWorldSpace, WorldSpacePosition, UniformOutgoingDirection);
        ImportanceDirectionalLightSamplingResult = ComputeImportanceDirectionalLightInput(SamplingState, UtilityData.ActiveDirectionalLightsCount, NormalInWorldSpace, WorldSpacePosition, ImportanceOutgoingDirection);
        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of uniformly sampled directional light and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of importance sampled directional light and the surface

        if (UniformDirectionalLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, UniformOutgoingDirection, NormalInWorldSpace, SamplingState);
            float NDotL = clamp(dot(UniformOutgoingDirection, NormalInWorldSpace), 0, 1);

            MaterialInteractionEvaluationResult1 = NDotL * MaterialInteractionEvaluationResult1 * UniformDirectionalLightSamplingResult.xyz / UniformDirectionalLightSamplingResult.w;
        }

        if (ImportanceDirectionalLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, ImportanceOutgoingDirection, NormalInWorldSpace, SamplingState);
            float NDotL = clamp(dot(ImportanceOutgoingDirection, NormalInWorldSpace), 0, 1);

            MaterialInteractionEvaluationResult2 = NDotL * MaterialInteractionEvaluationResult2 * ImportanceDirectionalLightSamplingResult.xyz / ImportanceDirectionalLightSamplingResult.w;
        }

        float PDFSUM = UniformDirectionalLightSamplingResult.w + ImportanceDirectionalLightSamplingResult.w;
        float W1 = UniformDirectionalLightSamplingResult.w / PDFSUM;
        float W2 = ImportanceDirectionalLightSamplingResult.w / PDFSUM;

        DirectionalLightResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2;
        TotalIncomingLight += W1 * UniformDirectionalLightSamplingResult.xyz + W2 * ImportanceDirectionalLightSamplingResult.xyz;
    }

    if (UtilityData.ActivePointLightsCount != 0)
    {
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        UniformPointLightSamplingResult = ComputeUniformPointLightInput(SamplingState, UtilityData.ActivePointLightsCount, NormalInWorldSpace, WorldSpacePosition, UniformOutgoingDirection);
        ImportancePointLightSamplingResult = ComputeImportancePointLightInput(SamplingState, UtilityData.ActivePointLightsCount, NormalInWorldSpace, WorldSpacePosition, ImportanceOutgoingDirection);
        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of uniformly sampled point light and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of importance sampled point light and the surface

        if (UniformPointLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, UniformOutgoingDirection, NormalInWorldSpace, SamplingState);
            float NDotL = clamp(dot(UniformOutgoingDirection, NormalInWorldSpace), 0, 1);

            MaterialInteractionEvaluationResult1 = NDotL * MaterialInteractionEvaluationResult1 * UniformPointLightSamplingResult.xyz / UniformPointLightSamplingResult.w;
        }

        if (ImportancePointLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, ImportanceOutgoingDirection, NormalInWorldSpace, SamplingState);
            float NDotL = clamp(dot(ImportanceOutgoingDirection, NormalInWorldSpace), 0, 1);

            MaterialInteractionEvaluationResult2 = NDotL * MaterialInteractionEvaluationResult2 * ImportancePointLightSamplingResult.xyz / ImportancePointLightSamplingResult.w;
        }

        float PDFSUM = UniformPointLightSamplingResult.w + ImportancePointLightSamplingResult.w;
        float W1 = UniformPointLightSamplingResult.w / PDFSUM;
        float W2 = ImportancePointLightSamplingResult.w / PDFSUM;

        PointLightResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2;
        TotalIncomingLight += W1 * UniformPointLightSamplingResult.xyz + W2 * ImportancePointLightSamplingResult.xyz;
    }

    if (UtilityData.ActiveSpotLightsCount != 0)
    {
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        UniformSpotLightSamplingResult = ComputeUniformSpotLightInput(SamplingState, UtilityData.ActiveSpotLightsCount, NormalInWorldSpace, WorldSpacePosition, UniformOutgoingDirection);
        ImportanceSpotLightSamplingResult = ComputeImportanceSpotLightInput(SamplingState, UtilityData.ActiveSpotLightsCount, NormalInWorldSpace, WorldSpacePosition, ImportanceOutgoingDirection);
        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of uniformly sampled spot light and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of importance sampled spot light and the surface

        if (UniformSpotLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, UniformOutgoingDirection, NormalInWorldSpace, SamplingState);
            float NDotL = clamp(dot(UniformOutgoingDirection, NormalInWorldSpace), 0, 1);

            MaterialInteractionEvaluationResult1 = NDotL * MaterialInteractionEvaluationResult1 * UniformSpotLightSamplingResult.xyz / UniformSpotLightSamplingResult.w;
        }

        if (ImportanceSpotLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, ImportanceOutgoingDirection, NormalInWorldSpace, SamplingState);
            float NDotL = clamp(dot(ImportanceOutgoingDirection, NormalInWorldSpace), 0, 1);

            MaterialInteractionEvaluationResult2 = NDotL * MaterialInteractionEvaluationResult2 * ImportanceSpotLightSamplingResult.xyz / ImportanceSpotLightSamplingResult.w;
        }

        float PDFSUM = UniformSpotLightSamplingResult.w + ImportanceSpotLightSamplingResult.w;
        float W1 = UniformSpotLightSamplingResult.w / PDFSUM;
        float W2 = ImportanceSpotLightSamplingResult.w / PDFSUM;

        SpotLightResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2;
        TotalIncomingLight += W1 * UniformSpotLightSamplingResult.xyz + W2 * ImportanceSpotLightSamplingResult.xyz;
    }

    if (UtilityData.ActiveAreaLightsCount != 0)
    {
        vec3 ImportanceOutgoingDirection = vec3(0);
        vec3 BXDFOutgoingDirection = RayData.Direction.xyz; ///We already have bxdf direction
        float NDotL = 0;
        ImportanceAreaLightSamplingResult = ComputeImportanceAreaLightInput(SamplingState, UtilityData.ActiveAreaLightsCount, NormalInWorldSpace, WorldSpacePosition, NDotL, ImportanceOutgoingDirection);
        BXDFAreaLightSamplingResult = ComputeBXDFAreaLightInput(SamplingState, NormalInWorldSpace, WorldSpacePosition, BXDFOutgoingDirection, MaterialScatteringPDF);
        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of importance sampled area light and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of bxdf sampled area light and the surface

        if (ImportanceAreaLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, ImportanceOutgoingDirection, NormalInWorldSpace, SamplingState);
            MaterialInteractionEvaluationResult1 = NDotL * MaterialInteractionEvaluationResult1 * ImportanceAreaLightSamplingResult.xyz / ImportanceAreaLightSamplingResult.w;
        }

        if (BXDFAreaLightSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, BXDFOutgoingDirection, NormalInWorldSpace, SamplingState);
            NDotL = clamp(dot(ImportanceOutgoingDirection, NormalInWorldSpace), 0, 1);

            MaterialInteractionEvaluationResult2 = NDotL * MaterialInteractionEvaluationResult2 * BXDFAreaLightSamplingResult.xyz / BXDFAreaLightSamplingResult.w;
        }

        float PDFSUM = ImportanceAreaLightSamplingResult.w + BXDFAreaLightSamplingResult.w;
        float W1 = ImportanceAreaLightSamplingResult.w / PDFSUM;
        float W2 = BXDFAreaLightSamplingResult.w / PDFSUM;

        AreaLightResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2;
        TotalIncomingLight += W1 * ImportanceAreaLightSamplingResult.xyz + W2 * BXDFAreaLightSamplingResult.xyz;
    }

    if (true/*UtilityData.IBLIsActive*/)
    {
        vec3 UniformOutgoingDirection = vec3(0);
        vec3 ImportanceOutgoingDirection = vec3(0);
        vec3 BXDFOutgoingDirection = RayData.Direction.xyz; ///We already have bxdf direction
        UniformIBLSamplingResult = ComputeUniformIBLInput(SamplingState, UniformOutgoingDirection, NormalInWorldSpace, WorldSpacePosition);
        ImportanceIBLSamplingResult = ComputeImportanceIBLInput(SamplingState, ImportanceOutgoingDirection, NormalInWorldSpace, WorldSpacePosition);
        BXDFIBLSamplingResult = ComputeBXDFIBLInput(SamplingState, BXDFOutgoingDirection, NormalInWorldSpace, WorldSpacePosition);
        vec3 MaterialInteractionEvaluationResult1 = vec3(0); /// Interaction result of uniform sampled IBL and the surface
        vec3 MaterialInteractionEvaluationResult2 = vec3(0); /// Interaction result of importance sampled IBL and the surface
        vec3 MaterialInteractionEvaluationResult3 = vec3(0); /// Interaction result of bxdf sampled IBL and the surface

        if (UniformIBLSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult1 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, UniformOutgoingDirection, NormalInWorldSpace, SamplingState);
            MaterialInteractionEvaluationResult1 = MaterialInteractionEvaluationResult1 * UniformIBLSamplingResult.xyz / UniformIBLSamplingResult.w;
        }

        if (ImportanceIBLSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult2 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, ImportanceOutgoingDirection, NormalInWorldSpace, SamplingState);
            MaterialInteractionEvaluationResult2 = MaterialInteractionEvaluationResult2 * ImportanceIBLSamplingResult.xyz / ImportanceIBLSamplingResult.w;
        }

        if (BXDFIBLSamplingResult.w != 0)
        {
            MaterialInteractionEvaluationResult3 = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, BXDFOutgoingDirection, NormalInWorldSpace, SamplingState);
            MaterialInteractionEvaluationResult3 = MaterialInteractionEvaluationResult3 * BXDFIBLSamplingResult.xyz / BXDFIBLSamplingResult.w;
        }

        float PDFSUM = UniformIBLSamplingResult.w + ImportanceIBLSamplingResult.w + BXDFIBLSamplingResult.w;
        float W1 = UniformIBLSamplingResult.w / PDFSUM;
        float W2 = ImportanceIBLSamplingResult.w / PDFSUM;
        float W3 = BXDFIBLSamplingResult.w / PDFSUM;

        IBLResult = W1 * MaterialInteractionEvaluationResult1 + W2 * MaterialInteractionEvaluationResult2 + W3 * MaterialInteractionEvaluationResult3;
        TotalIncomingLight += W1 * UniformIBLSamplingResult.xyz + W2 * ImportanceIBLSamplingResult.xyz + W3 * BXDFIBLSamplingResult.xyz;
    }

    RayData.Origin.xyz = WorldSpacePosition;

    vec3 MaterialSamplingResult = EvaluateMaterialInteraction(Material, RayData.RayFlags, Incoming, RayData.Direction.xyz, NormalInWorldSpace, SamplingState);
    NDotI = clamp(dot(-Incoming, NormalInWorldSpace), 0, 1);
    MaterialSamplingResult = MaterialSamplingResult * NDotI / MaterialScatteringPDF;

    vec3 CumulativeMaterialColor = CumulativeMaterialColorBuffer[PixelIndex].xyz;
    CumulativeMaterialColor *= MaterialSamplingResult;
    CumulativeMaterialColorBuffer[PixelIndex] = vec4(CumulativeMaterialColor, 1);

    vec3 BounceInput = vec3(0);
    BounceInput += DirectionalLightResult;
    BounceInput += PointLightResult;
    BounceInput += SpotLightResult;
    BounceInput += AreaLightResult;
    BounceInput += IBLResult;
    ThroughputBuffer[PixelIndex].xyz = ThroughputBuffer[PixelIndex].xyz + BounceInput;

    if ((PushConstants.BounceIndex == LAST_DIFFUSE_BOUNCE && CheckFlag(RayData.RayFlags, DIFFUSE_LAYER))
    || (PushConstants.BounceIndex == LAST_REFLECTION_BOUNCE && CheckFlag(RayData.RayFlags, SPECULAR_LAYER))
    || (PushConstants.BounceIndex == LAST_REFRACTION_BOUNCE && CheckFlag(RayData.RayFlags, TRANSMISSION_LAYER))
    || CheckFlag(RayData.RayFlags, EMISSION_LAYER)
    || MaterialScatteringPDF < 0.)
    {
        RayDataBuffer[PixelIndex].RayFlags = RAY_DATA_RAY_MISSED;
        imageStore(OutcomingImage, ivec2(PixelCoords), vec4(ThroughputBuffer[PixelIndex].xyz , 1));
        return;
    }

    if (PushConstants.BounceIndex == LAST_BOUNCE)
    {
        imageStore(OutcomingImage, ivec2(PixelCoords), vec4(ThroughputBuffer[PixelIndex].xyz , 1));
        return;
    }

    RayDataBuffer[PixelIndex] = RayData;
    NormalBuffer[PixelIndex] = vec4(NormalInWorldSpace, 1);

    if(PushConstants.BounceIndex == 0)
    {
        DebugGlobal = vec4(AreaLightResult, 0);
        SaveAOVs(PixelCoords, NormalInWorldSpace, NormalInWorldSpace, TextureCoords, WorldSpacePosition, 1., Depth,
        Material.BaseColor, TotalIncomingLight, Hit.RenderableIndex, Hit.PrimitiveIndex, PushConstants.MaterialIndex, DebugGlobal);
    }
}
