#version 460#extension GL_EXT_ray_tracing : require#extension GL_EXT_nonuniform_qualifier : enable#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require#extension GL_EXT_scalar_block_layout : enable#extension GL_EXT_buffer_reference2 : requirestruct HitPayload{    int InstanceIndex;    int PrimitiveIndex;    vec2 HitAttributes;};layout (set = 0, binding = 0) uniform accelerationStructureEXT TopLevelAS;layout (set = 0, binding = 1) uniform CameraBufferObject{    mat4 ViewMatrix;    mat4 ProjectionMatrix;} CameraBuffer;layout (set = 0, binding = 2, rgba32f) uniform image2D Image;struct FRenderable{    vec3 RenderableColor;    int RenderableIndex;    uint RenderablePropertyMask;    uint64_t VertexBufferAddress;    uint64_t IndexBufferAddress;};layout (set = 0, binding = 3) buffer RenderableBufferObject{    FRenderable Renderables[];} RenderableBuffer;layout(set = 0, binding = 4) uniform sampler2D IBITextureSampelr;struct FVertex{    vec3 Position;    vec3 Normal;    vec2 TexCoord;};layout(buffer_reference, scalar) buffer Vertices{    FVertex V[];};layout(buffer_reference, scalar) buffer Indices{    ivec3 I[];};layout (location = 0) rayPayloadEXT HitPayload PRD;void main(){    const vec2 PixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5f);    const vec2 InUV = PixelCenter/vec2(gl_LaunchSizeEXT.xy);    vec2 D = InUV * 2.0f - 1.f;    vec4 Origin = inverse(CameraBuffer.ViewMatrix) * vec4(0.f, 0.f, 0.f, 1.f);    vec4 Target = inverse(CameraBuffer.ProjectionMatrix) * vec4(D.x, D.y, 1.f, 1.f);    vec4 Direction = inverse(CameraBuffer.ViewMatrix) * vec4(normalize(Target.xyz), 0.f);    vec3 NormalizedDirection = normalize(Direction.xyz);    float Tmp = atan(NormalizedDirection.z, NormalizedDirection.x);    float Phi = Tmp < 0.f ? (Tmp + (2 * 3.14159265357)) : Tmp;    float Theta = acos(NormalizedDirection.y);    Phi /= 2.f * 3.14159265357;    Theta /= 3.14159265357;    uint RayFlags = gl_RayFlagsOpaqueEXT;    float tMin = 0.001f;    float tMax = 10000.f;    traceRayEXT(TopLevelAS, RayFlags, 0xFF, 0, 0, 0, Origin.xyz, tMin, Direction.xyz, tMax, 0);    if (PRD.InstanceIndex == 10)    {        imageStore(Image, ivec2(gl_LaunchIDEXT.xy), texture(IBITextureSampelr, vec2(Phi, Theta)));    }    else    {        FRenderable Renderable = RenderableBuffer.Renderables[nonuniformEXT(PRD.InstanceIndex)];        Indices Inds = Indices(Renderable.IndexBufferAddress);        Vertices Verts = Vertices(Renderable.VertexBufferAddress);        int Index = PRD.PrimitiveIndex * 3;        FVertex V0 = Verts.V[Index];        FVertex V1 = Verts.V[Index + 1];        FVertex V2 = Verts.V[Index + 2];        vec3 Normal = cross(normalize(V1.Position - V0.Position), normalize(V2.Position - V0.Position));        imageStore(Image, ivec2(gl_LaunchIDEXT.xy), vec4(nrm, 1.f));    }}