#version 460#extension GL_EXT_ray_tracing : require#extension GL_EXT_nonuniform_qualifier : enablestruct HitPayload{    int InstanceIndex;};layout (set = 0, binding = 0) uniform accelerationStructureEXT TopLevelAS;layout (set = 0, binding = 1) uniform CameraBufferObject{    mat4 ViewMatrix;    mat4 ProjectionMatrix;} CameraBuffer;layout (set = 0, binding = 2, rgba32f) uniform image2D Image;struct Renderable{    vec3 RenderableColor;    int RenderableIndex;    uint RenderablePropertyMask;};layout (set = 0, binding = 3) buffer RenderableBufferObject{    Renderable Renderables[];} RenderableBuffer;layout(set = 0, binding = 4) uniform sampler2D IBITextureSampelr;layout (location = 0) rayPayloadEXT HitPayload PRD;void main(){    const vec2 PixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5f);    const vec2 InUV = PixelCenter/vec2(gl_LaunchSizeEXT.xy);    vec2 D = InUV * 2.0f - 1.f;    vec4 Origin = inverse(CameraBuffer.ViewMatrix) * vec4(0.f, 0.f, 0.f, 1.f);    vec4 Target = inverse(CameraBuffer.ProjectionMatrix) * vec4(D.x, D.y, 1.f, 1.f);    vec4 Direction = inverse(CameraBuffer.ViewMatrix) * vec4(normalize(Target.xyz), 0.f);    vec3 NormalizedDirection = normalize(Direction.xyz);    float Tmp = atan(NormalizedDirection.z, NormalizedDirection.x);    float Phi = Tmp < 0.f ? (Tmp + (2 * 3.14159265357)) : Tmp;    float Theta = acos(NormalizedDirection.y);    Phi /= 2.f * 3.14159265357;    Theta /= 3.14159265357;    uint RayFlags = gl_RayFlagsOpaqueEXT;    float tMin = 0.001f;    float tMax = 10000.f;    traceRayEXT(TopLevelAS, RayFlags, 0xFF, 0, 0, 0, Origin.xyz, tMin, Direction.xyz, tMax, 0);    if (PRD.InstanceIndex == 10)    {        imageStore(Image, ivec2(gl_LaunchIDEXT.xy), texture(IBITextureSampelr, vec2(Phi, Theta)));    }    else    {        imageStore(Image, ivec2(gl_LaunchIDEXT.xy), vec4(RenderableBuffer.Renderables[nonuniformEXT(PRD.InstanceIndex)].RenderableColor, 1.f));    }}