#version 460#extension GL_EXT_ray_tracing : require#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require#extension GL_EXT_nonuniform_qualifier : enable#extension GL_EXT_scalar_block_layout : enable#extension GL_EXT_buffer_reference2 : requirestruct HitPayload{    vec3 Color;    vec2 IBLCoordinates;};hitAttributeEXT vec2 Attributes;layout(location = 0) rayPayloadInEXT HitPayload Hit;struct FVertex{    vec3 Position;    vec3 Normal;    vec2 TexCoord;};layout(buffer_reference, scalar) buffer Vertices{    FVertex V[];};layout(buffer_reference, scalar) buffer Indices{    ivec3 I[];};struct FRenderable{    vec3 RenderableColor;    int RenderableIndex;    uint RenderablePropertyMask;    uint64_t VertexBufferAddress;    uint64_t IndexBufferAddress;};layout (set = 0, binding = 3) buffer RenderableBufferObject{    FRenderable Renderables[];} RenderableBuffer;void main(){    FRenderable Renderable = RenderableBuffer.Renderables[nonuniformEXT(gl_InstanceID)];    Indices Inds = Indices(Renderable.IndexBufferAddress);    Vertices Verts = Vertices(Renderable.VertexBufferAddress);    int Index = gl_PrimitiveID * 3;    FVertex V0 = Verts.V[Index];    FVertex V1 = Verts.V[Index + 1];    FVertex V2 = Verts.V[Index + 2];    vec3 Normal = normalize(cross((V1.Position - V0.Position), (V2.Position - V0.Position)));    Hit.Color = Normal;}